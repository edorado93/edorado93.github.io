---
layout: post
title: "Let‚Äôs Backtrack And Save Some Queens"
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Let‚Äôs Backtrack And Save Some Queens</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 100%;
        margin: auto;
      }
      section {
        width: 100%;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 100%;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Let‚Äôs Backtrack And Save Some Queens</h1>
</header>
<section data-field="subtitle" class="p-summary">
That‚Äôs a weird looking title, that probably doesn‚Äôt make sense right now. But trust me, this is a pretty long post and is really fun!
</section>
<section data-field="body" class="e-content">
<section name="ed44" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c283" id="c283" class="graf graf--h3 graf--leading graf--title"></h3></div><div class="section-inner sectionLayout--outsetColumn"><figure name="5d03" id="5d03" class="graf graf--figure graf--layoutOutsetCenter graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 750px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="1*uHVAfKRI6gPxiAmzCTnRCg.jpeg" data-width="1200" data-height="900" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1000/1*uHVAfKRI6gPxiAmzCTnRCg.jpeg"></div><figcaption class="imageCaption"><a href="https://derickbailey.com/wp-content/uploads/2015/01/recursion1.jpg" data-href="https://derickbailey.com/wp-content/uploads/2015/01/recursion1.jpg" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://derickbailey.com/wp-content/uploads/2015/01/recursion1.jpg</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="88b9" id="88b9" class="graf graf--p graf-after--figure">That‚Äôs a weird looking title, that probably doesn‚Äôt make sense right now. But trust me, this is a pretty long post and is really fun!</p><h4 name="db6f" id="db6f" class="graf graf--h4 graf-after--p">What is Backtracking¬†?</h4><p name="ef53" id="ef53" class="graf graf--p graf-after--h4"><a href="https://en.wikipedia.org/wiki/Backtracking" data-href="https://en.wikipedia.org/wiki/Backtracking" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Backtracking</a> is a standard problem solving technique based on <a href="https://medium.freecodecamp.org/recursion-recursion-recursion-4db8890a674d" data-href="https://medium.freecodecamp.org/recursion-recursion-recursion-4db8890a674d" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">recursion</a>.</p><p name="102a" id="102a" class="graf graf--p graf-after--p">A backtracking algorithm tries to build a solution to a computational problem incrementally. Whenever the algorithm needs to decide between multiple alternatives to the next component of the solution, it simply tries all possible options recursively.</p><p name="500c" id="500c" class="graf graf--p graf-after--p"><a href="https://en.wikipedia.org/wiki/Depth-first_search" data-href="https://en.wikipedia.org/wiki/Depth-first_search" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Depth First Search</a> (DFS) uses the concept of backtracking at its very core. So, in DFS, we basically try exploring all the paths from the given node recursively until we reach the goal. After we explore a particular branch of a tree in DFS, we can land up in two possible states.</p><ul class="postList"><li name="ee9b" id="ee9b" class="graf graf--li graf-after--p">We found the goal state in which case we simply exit.</li><li name="ad94" id="ad94" class="graf graf--li graf-after--li">Or, we did not find the goal state and we hit a dead end. In this scenario, we <strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">backtrack to the last checkpoint </em></strong>and we then try out a different branch.</li></ul><p name="51bc" id="51bc" class="graf graf--p graf-after--li">For detailed introduction to the Depth First Search Algorithm, go through</p><div name="1a77" id="1a77" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13" data-href="https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13"><strong class="markup--strong markup--mixtapeEmbed-strong">Deep Dive Through A Graph: DFS Traversal</strong><br><em class="markup--em markup--mixtapeEmbed-em">For better or for worse, there‚Äôs always more than one way to do something. Luckily for us, in the world of software and‚Ä¶</em>medium.com</a><a href="https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="bb894314fd4f6106b914ca6c727c3402" data-thumbnail-img-id="1*gb8XfmH7x8fJniMeXk4uHg.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*gb8XfmH7x8fJniMeXk4uHg.jpeg);"></a></div><p name="da54" id="da54" class="graf graf--p graf-after--mixtapeEmbed">and for a detailed intro to backtracking and recursion in general, check out the following two articles.</p><div name="5c3d" id="5c3d" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/@andreaiacono/backtracking-explained-7450d6ef9e1a" data-href="https://medium.com/@andreaiacono/backtracking-explained-7450d6ef9e1a" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/@andreaiacono/backtracking-explained-7450d6ef9e1a"><strong class="markup--strong markup--mixtapeEmbed-strong">Backtracking explained</strong><br><em class="markup--em markup--mixtapeEmbed-em">Backtracking is one of my favourite algorithms because of its simplicity and elegance; it doesn‚Äôt always have great‚Ä¶</em>medium.com</a><a href="https://medium.com/@andreaiacono/backtracking-explained-7450d6ef9e1a" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="5e0934b7f97faaa007e516c4fd5af65f" data-thumbnail-img-id="1*UOupQbgJEDuOTgZSLg-EfQ.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*UOupQbgJEDuOTgZSLg-EfQ.png);"></a></div><div name="cc4b" id="cc4b" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://medium.freecodecamp.org/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9" data-href="https://medium.freecodecamp.org/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.freecodecamp.org/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9"><strong class="markup--strong markup--mixtapeEmbed-strong">How Recursion Works‚Ää‚Äî‚Ääexplained with flowcharts and a video</strong><br><em class="markup--em markup--mixtapeEmbed-em">‚ÄúIn order to understand recursion, one must first understand recursion.‚Äù</em>medium.freecodecamp.org</a><a href="https://medium.freecodecamp.org/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="b6725f4a6fbfe17fe20e9e11c9c2acab" data-thumbnail-img-id="1*FVSUmSQEEsagXaKa_ajtvA.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*FVSUmSQEEsagXaKa_ajtvA.png);"></a></div><p name="77cf" id="77cf" class="graf graf--p graf-after--mixtapeEmbed">Now that we are all pros in backtracking and recursion, let‚Äôs see what do ‚ÄúQueens‚Äù have to do with all this.</p><h3 name="447c" id="447c" class="graf graf--h3 graf-after--p">The Famous N-Queens¬†Problem</h3><p name="82ff" id="82ff" class="graf graf--p graf-after--h3"><a href="http://www.drdobbs.com/jvm/optimal-queens/184406068" data-href="http://www.drdobbs.com/jvm/optimal-queens/184406068" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Positioning queens</a> on a chess board is a classical problem in mathematics and computer science.</p><p name="fe79" id="fe79" class="graf graf--p graf-after--p">The <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle" data-href="https://en.wikipedia.org/wiki/Eight_queens_puzzle" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Queen‚Äôs Puzzle</a> (aka the eight queens puzzle), was originally published in 1848. It involves placing eight queens on an 8x8 chess board, in such a manner that no two queens can attack each other.</p><p name="c133" id="c133" class="graf graf--p graf-after--p">The queen happens to be the most powerful piece on the chess board, primarily because of the freedom of movement that it has.</p><p name="393f" id="393f" class="graf graf--p graf-after--p">The queen can move in 8 different directions, as illustrated in the image below:</p><figure name="4b47" id="4b47" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 417px; max-height: 397px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 95.19999999999999%;"></div><img class="graf-image" data-image-id="1*t_J-RtgpiipfiXhHs8uywg.jpeg" data-width="417" data-height="397" src="https://cdn-images-1.medium.com/max/800/1*t_J-RtgpiipfiXhHs8uywg.jpeg"></div><figcaption class="imageCaption">8 directions for the Queen‚Äôs movement.</figcaption></figure><p name="a89c" id="a89c" class="graf graf--p graf-after--figure">This freedom of movement is what makes the N-queens problem extremely hard.</p><p name="8d4e" id="8d4e" class="graf graf--p graf-after--p">Below is a short overview of how the remainder of this article progresses. We‚Äôll discuss 4 different algorithms to solve the problem:</p><ul class="postList"><li name="ad0f" id="ad0f" class="graf graf--li graf-after--p">The Brute Force solution.</li><li name="b8a6" id="b8a6" class="graf graf--li graf-after--li">Backtracking based solution.</li><li name="72c1" id="72c1" class="graf graf--li graf-after--li">Permutations based solution.</li><li name="41e1" id="41e1" class="graf graf--li graf-after--li">Finally, the seemingly crazy solution using Bit Magic.</li></ul><p name="ecc2" id="ecc2" class="graf graf--p graf-after--li">I would highly recommend reading through the solutions in this order. However, feel free to skip a solution if you‚Äôre already familiar with it.</p><p name="5c4c" id="5c4c" class="graf graf--p graf-after--p">The entire code for the solutions discussed below is available <a href="https://github.com/edorado93/Save-The-Queens/tree/master" data-href="https://github.com/edorado93/Save-The-Queens/tree/master" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">here</a>.</p><h3 name="4114" id="4114" class="graf graf--h3 graf-after--p">The Brute Force¬†Solution</h3><pre name="db6e" id="db6e" class="graf graf--pre graf-after--h3">while there is life on earth:<br>    try a possible arrangement of queens.</pre><figure name="6701" id="6701" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="1*Nclg6kDeZ7jWal80xCVt-Q.jpeg" data-width="1440" data-height="1080" src="https://cdn-images-1.medium.com/max/800/1*Nclg6kDeZ7jWal80xCVt-Q.jpeg"></div><figcaption class="imageCaption"><a href="https://i.ytimg.com/vi/keCgNXlq3Vo/maxresdefault.jpg" data-href="https://i.ytimg.com/vi/keCgNXlq3Vo/maxresdefault.jpg" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://i.ytimg.com/vi/keCgNXlq3Vo/maxresdefault.jpg</a></figcaption></figure><p name="27e7" id="27e7" class="graf graf--p graf-after--figure">We‚Äôve got an 8x8 chessboard, which means we have 64 different spots to place the queens. We need to calculate C(64, 8), or the <a href="http://www.mathwords.com/c/combination_formula.htm" data-href="http://www.mathwords.com/c/combination_formula.htm" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">number of combinations</a> of 64 objects, taken 8 at a time.</p><pre name="a36b" id="a36b" class="graf graf--pre graf-after--p">C(n,r) = n! / (r!(n‚àír)!)</pre><p name="57aa" id="57aa" class="graf graf--p graf-after--pre">We get around <strong class="markup--strong markup--p-strong">4.5 billion different combinations of placing the 8 queens on an 8x8 chessboard.</strong></p><p name="0945" id="0945" class="graf graf--p graf-after--p">The brute-force algorithm is as follows:</p><pre name="a1d8" id="a1d8" class="graf graf--pre graf-after--p">while there are untried configurations<br>{<br>   generate the next configuration<br>   if queens don&#39;t attack in this configuration then<br>   {<br>      print this configuration;<br>   }<br>}</pre><p name="cc5d" id="cc5d" class="graf graf--p graf-after--pre">That‚Äôs a lot of permutations to check for a standard processor. We could use some sort of multi-processing solution (because checking one permutation is independent of another one).</p><p name="55e9" id="55e9" class="graf graf--p graf-after--p">But why do that when we have better algorithms to solve this problem?</p><h3 name="b3cd" id="b3cd" class="graf graf--h3 graf-after--p">Backtracking</h3><p name="0277" id="0277" class="graf graf--p graf-after--h3">We can do better than the na√Øve brute force solution for this problem. Consider the following pseudocode for the backtracking based solution:</p><pre name="13c3" id="13c3" class="graf graf--pre graf-after--p">1) Start in the leftmost column<br>2) If all queens are placed<br>    increment the number of solutions counter and return<br>3) Try all rows in the current column. Do following for every tried row.<br>    a) If the queen can be placed safely in this row then mark this [row, column] as part of the solution and recursively check if placing queen here leads to a solution.</pre><pre name="d035" id="d035" class="graf graf--pre graf-after--pre">    b) If placing queen in [row, column] leads to a solution then   increment the number of solutions counter and return</pre><pre name="e7f8" id="e7f8" class="graf graf--pre graf-after--pre">    c) If placing queen doesn&#39;t lead to a solution then unmark this [row, column] (Backtrack) and go to step (a) to try other rows.</pre><pre name="fc4f" id="fc4f" class="graf graf--pre graf-after--pre">4) If all rows have been tried and nothing worked, return, to trigger backtracking.</pre><p name="8334" id="8334" class="graf graf--p graf-after--pre">The pseudocode looks simple enough, and you can checkout the python based code for this <a href="http://www.geeksforgeeks.org/backtracking-set-3-n-queen-problem/" data-href="http://www.geeksforgeeks.org/backtracking-set-3-n-queen-problem/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">here</a>. I won‚Äôt be providing description for the backtracking algorithm here.</p><p name="c514" id="c514" class="graf graf--p graf-after--p">I would however, like to<strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong>discuss an<strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em>optimization</strong> to reduce the time complexity of checking if we can place a queen in a cell on the board.</p><p name="4526" id="4526" class="graf graf--p graf-after--p">An important piece of the algorithm is where we have to check if a queen can be placed in a cell <code class="markup--code markup--p-code">[i, j]</code>. This step takes a long time. Let‚Äôs look at a brute-force way to do this, and then at an optimized version.</p><figure name="531c" id="531c" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/6c0c29435574f70006a4f548bd5e5d49.js"></script></figure><p name="f9b6" id="f9b6" class="graf graf--p graf-after--figure">This has a <a href="https://www.youtube.com/watch?v=KSNx22U4uWE" data-href="https://www.youtube.com/watch?v=KSNx22U4uWE" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank"><strong class="markup--strong markup--p-strong">time</strong> <strong class="markup--strong markup--p-strong">complexity</strong></a><strong class="markup--strong markup--p-strong"> of O(N),</strong> and this will be called multiple times for every cell on the board.</p><p name="9e17" id="9e17" class="graf graf--p graf-after--p">We can however, make use of some additional data structures to speed up the validity check for placing a queen on a cell <code class="markup--code markup--p-code">[i, j]</code>. This will bring down the complexity to <code class="markup--code markup--p-code">O(1)</code>‚Ää‚Äî‚Ääin other words, constant time. This is a huge reduction!.</p><figure name="5264" id="5264" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/3b0cdbd4a3070544fbc332ce7b25175b.js"></script></figure><p name="e261" id="e261" class="graf graf--p graf-after--figure">The keys points in this piece of code are the following¬†:</p><ul class="postList"><li name="83cd" id="83cd" class="graf graf--li graf-after--p">All the elements in a particular diagonal (from left top to right bottom) have the same value for <code class="markup--code markup--li-code">row‚Ää‚Äî‚Ääcolumn</code>¬†.</li><li name="68d2" id="68d2" class="graf graf--li graf-after--li">All the elements in a particular anti-diagonal (from right top to left bottom) have the same value for <code class="markup--code markup--li-code">row + column</code>¬†.</li></ul><p name="6f6d" id="6f6d" class="graf graf--p graf-after--li">This optimization brings down the <code class="markup--code markup--p-code">isSafe</code><em class="markup--em markup--p-em"> </em>complexity to<em class="markup--em markup--p-em"> </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">O(1)</em></code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">. </em></strong>Hurray üòÉ.</p><p name="8bca" id="8bca" class="graf graf--p graf-after--p">Now that we‚Äôre done with the basic algorithms for N-Queens. Let‚Äôs move onto some more complicated ones that run much faster than the ones described above.</p><h3 name="bb19" id="bb19" class="graf graf--h3 graf-after--p">Permutations and¬†N-Queens</h3><p name="2e90" id="2e90" class="graf graf--p graf-after--h3">The idea behind this algorithm is pretty simple. Consider the following facts about the placement of each queen:</p><ul class="postList"><li name="3f01" id="3f01" class="graf graf--li graf-after--p">We can only place one queen in a row.</li><li name="104e" id="104e" class="graf graf--li graf-after--li">Same thing can be said for each column.</li><li name="0283" id="0283" class="graf graf--li graf-after--li">This means that all successful solutions are just going to be <strong class="markup--strong markup--li-strong">permutations of the column subscripts.</strong></li><li name="36c9" id="36c9" class="graf graf--li graf-after--li">Each successive row has one fewer candidate position for the queen to be placed.</li></ul><p name="569c" id="569c" class="graf graf--p graf-after--li">Going by this logic, the problem space comes down to just <strong class="markup--strong markup--p-strong">8! = 40,320.</strong></p><p name="19ba" id="19ba" class="graf graf--p graf-after--p">That gives a lot less options to try and to find the solutions for our problem.</p><p name="cfae" id="cfae" class="graf graf--p graf-after--p">Let‚Äôs look at the pseudo-code for this approach:</p><pre name="daeb" id="daeb" class="graf graf--pre graf-after--p">* Start with an initial permutation of the queens lined up along one of the diagonals. </pre><pre name="3f8a" id="3f8a" class="graf graf--pre graf-after--pre">* To position a queen on row j<br>    * If j has reached N, you have a valid solution. Process it as               valid.<br>    * Loop on k from j to N<br>       * Swap board[j] and board[k]. <br>       * Check if a queen can be placed on (row, board[row])<br>           * If yes, then place a queen and recurse for row j+1<br>       * Undo placing a queen on (row, board[row])<br>   * Undo the swaps done.   </pre><p name="d81f" id="d81f" class="graf graf--p graf-after--pre">For greater clarity, let‚Äôs look at the code as well:</p><figure name="5f12" id="5f12" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/814d06ba5a9fa14fe248ce950633c057.js"></script></figure><p name="f37f" id="f37f" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Note: </strong><code class="markup--code markup--p-code">board[i]</code> stores the column number where a queen has been placed in row <code class="markup--code markup--p-code">i.</code> Hence, the cell value is given by <code class="markup--code markup--p-code">(i, board[i])</code>.</p><p name="e109" id="e109" class="graf graf--p graf-after--p">This optimization speeds up the calculation a lot, because of the highly reduced board space to consider while placing the queens.</p><p name="78fe" id="78fe" class="graf graf--p graf-after--p">The speed up becomes more prominent as we increase the size of the board, and hence the number of queens to be placed.</p><p name="8f7f" id="8f7f" class="graf graf--p graf-after--p">Also, the validity check for a particular cell becomes simpler, because now we only have to check diagonals and the anti-diagonals.</p><h3 name="7275" id="7275" class="graf graf--h3 graf-after--p">Let‚Äôs see some Bit¬†Magic!</h3><p name="b363" id="b363" class="graf graf--p graf-after--h3">This particular solution to the problem is something that was practically Greek to me the first time I went through it.</p><p name="e4da" id="e4da" class="graf graf--p graf-after--p">That‚Äôs understandable though, because hey, it‚Äôs <strong class="markup--strong markup--p-strong">bit</strong> <strong class="markup--strong markup--p-strong">magic!</strong></p><p name="99c0" id="99c0" class="graf graf--p graf-after--p">But thankfully, I found this amazing <a href="http://gregtrowbridge.com/a-bitwise-solution-to-the-n-queens-problem-in-javascript/" data-href="http://gregtrowbridge.com/a-bitwise-solution-to-the-n-queens-problem-in-javascript/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">blog post</a> explaining the entire algorithm line by line. The code is in JavaScript. I‚Äôll be describing the same thing but for the code in python. Read whichever post suits you¬†:)</p><p name="e0bc" id="e0bc" class="graf graf--p graf-after--p">The best way to go about explaining this algorithm is by putting up the code first üòâ</p><figure name="e2ba" id="e2ba" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/3adb5593de64068f1cdd1afabe94e1fd.js"></script></figure><figure name="bc6b" id="bc6b" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="1*yAqiXTpbu-6mRHQ5SjYn5Q.jpeg" data-width="1024" data-height="768" src="https://cdn-images-1.medium.com/max/800/1*yAqiXTpbu-6mRHQ5SjYn5Q.jpeg"></div><figcaption class="imageCaption"><a href="http://mymemes.biz/wp-content/uploads/2017/10/meme-magic-59df0f3650800.jpg" data-href="http://mymemes.biz/wp-content/uploads/2017/10/meme-magic-59df0f3650800.jpg" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">http://mymemes.biz/wp-content/uploads/2017/10/meme-magic-59df0f3650800.jpg</a></figcaption></figure><p name="6a1b" id="6a1b" class="graf graf--p graf-after--figure">The algorithm works using the same basic idea that was discussed before. We only need to check three things before placing a queen on a certain square:</p><ol class="postList"><li name="e83a" id="e83a" class="graf graf--li graf-after--p">The square‚Äôs column doesn‚Äôt have any other queens on it</li><li name="7e91" id="7e91" class="graf graf--li graf-after--li">The square‚Äôs left diagonal doesn‚Äôt have any other queens on it</li><li name="a53a" id="a53a" class="graf graf--li graf-after--li">The square‚Äôs right diagonal doesn‚Äôt have any other queens on it</li></ol><p name="3d38" id="3d38" class="graf graf--p graf-after--li">The code might look like a black box that just seems to work. That‚Äôs how I felt the first time I read this insanely fast piece of code.</p><p name="3306" id="3306" class="graf graf--p graf-after--p">Let‚Äôs try and break it down line by line.</p><h4 name="a0ef" id="a0ef" class="graf graf--h4 graf-after--p">Line #1</h4><p name="b90f" id="b90f" class="graf graf--p graf-after--h4">You‚Äôll notice that the function accepts 4 parameters:</p><ol class="postList"><li name="04bc" id="04bc" class="graf graf--li graf-after--p">column</li><li name="932f" id="932f" class="graf graf--li graf-after--li">left_diagonal</li><li name="9e51" id="9e51" class="graf graf--li graf-after--li">right_diagonal</li><li name="dd30" id="dd30" class="graf graf--li graf-after--li">queens_placed</li></ol><p name="f044" id="f044" class="graf graf--p graf-after--li">The <code class="markup--code markup--p-code u-paddingRight0 u-marginRight0"><strong class="markup--strong markup--p-strong">queens_placed</strong> </code>is self explanatory. We need to keep track of how many queens we have placed till now for the recursion to terminate at one point.</p><p name="ea1e" id="ea1e" class="graf graf--p graf-after--p">The three variables <code class="markup--code markup--p-code">column</code>, <code class="markup--code markup--p-code">left_diagonal</code> and <code class="markup--code markup--p-code">right_diagonal </code>are basically integers, but they are being treated as a sequence of bits for the purpose of this algorithm. These variables help us determine the open positions on the current row for a queen to be placed.</p><p name="647a" id="647a" class="graf graf--p graf-after--p">Let‚Äôs look at the picture below:</p><ul class="postList"><li name="aa50" id="aa50" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">ld</code> = left_diagonal</li><li name="56cc" id="56cc" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">cols</code> = column</li><li name="a277" id="a277" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">rd</code> = right_diagonal</li></ul><figure name="d164" id="d164" class="graf graf--figure graf-after--li"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 358px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 51.2%;"></div><img class="graf-image" data-image-id="1*u0D6tQbzP98BCTD54GfV9A.png" data-width="1176" data-height="602" src="https://cdn-images-1.medium.com/max/800/1*u0D6tQbzP98BCTD54GfV9A.png"></div><figcaption class="imageCaption"><a href="http://gregtrowbridge.com/a-bitwise-solution-to-the-n-queens-problem-in-javascript/" data-href="http://gregtrowbridge.com/a-bitwise-solution-to-the-n-queens-problem-in-javascript/" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">http://gregtrowbridge.com/a-bitwise-solution-to-the-n-queens-problem-in-javascript/</a></figcaption></figure><p name="0590" id="0590" class="graf graf--p graf-after--figure">Ignore the <code class="markup--code markup--p-code">poss</code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong>variable for now. We‚Äôll get to it later on.</p><h4 name="9cec" id="9cec" class="graf graf--h4 graf-after--p">Lines #2‚Äì6</h4><p name="4533" id="4533" class="graf graf--p graf-after--h4">These lines of code simply handle the base case for recursion. When we have placed <code class="markup--code markup--p-code">N</code> queens on our N by N board, we increment the number of solutions counter and print the solution if the appropriate flag has been set while running (see the entire code for this flag).</p><h4 name="0d3a" id="0d3a" class="graf graf--h4 graf-after--p">Line #8</h4><p name="6e53" id="6e53" class="graf graf--p graf-after--h4">This finds the <code class="markup--code markup--p-code">valid_spots</code> remaining on the current row. This is basically the <code class="markup--code markup--p-code">poss</code> variable depicted in the picture above.</p><pre name="07c5" id="07c5" class="graf graf--pre graf-after--p">valid_spots = self.all_ones &amp; <br>~(column | left_diagonal | right_diagonal)</pre><p name="499f" id="499f" class="graf graf--p graf-after--pre">For example, let‚Äôs say that after some number of iterations we have:</p><pre name="6304" id="6304" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">left_diagonal = 00011000<br>column = 11001001</code> <br><code class="markup--code markup--pre-code">right_diagonal = 00011100</code></pre><p name="7784" id="7784" class="graf graf--p graf-after--pre">The code <code class="markup--code markup--p-code">(column | left_diagonal | right_diagonal)</code> just does an ‚ÄúOR‚Äù operation, and ends up with the bit sequence 11011101.</p><p name="728b" id="728b" class="graf graf--p graf-after--p">Then, adding the <code class="markup--code markup--p-code">~</code> in front of that expression causes the resulting bit sequence to ‚Äúflip‚Äù (so all zeroes become ones and vice versa), and <code class="markup--code markup--p-code">valid_spots</code> would be set to 00100010.</p><p name="2f12" id="2f12" class="graf graf--p graf-after--p">So for the current row, the column number 0,1,3,4,5 and 7 are not available. We can only place a queen on column number 2 and 6. These are the only two spots that we will try.</p><h4 name="6504" id="6504" class="graf graf--h4 graf-after--p">Line #10</h4><pre name="372d" id="372d" class="graf graf--pre graf-after--h4">current_spot = -valid_spots &amp; valid_spots</pre><p name="30d9" id="30d9" class="graf graf--p graf-after--pre">This line finds the first non zero bit and stores it into <code class="markup--code markup--p-code">current_spot</code>. So it‚Äôs basically finding the first empty spot where we can place our queen (from the rightmost column).</p><p name="89fe" id="89fe" class="graf graf--p graf-after--p">This right here is what makes the algorithm so fast. We used bit operators to directly tell us the empty positions that are completely safe for us to place our queens. Hence, this leads to major speedup as you will see later on.</p><h4 name="9d24" id="9d24" class="graf graf--h4 graf-after--p">Line #11 and¬†12</h4><p name="dada" id="dada" class="graf graf--p graf-after--h4">Line #11 simply adds the queen being placed at the <code class="markup--code markup--p-code">current_spot</code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong>to our solution set so that we can print it later.</p><p name="cb32" id="cb32" class="graf graf--p graf-after--p">Line #12 marks the <code class="markup--code markup--p-code">current_spot</code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong>as unavailable. Remember, <a href="https://en.wikipedia.org/wiki/XOR_swap_algorithm" data-href="https://en.wikipedia.org/wiki/XOR_swap_algorithm" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">XORing</a> the same bits leads to 0.</p><h4 name="52c1" id="52c1" class="graf graf--h4 graf-after--p">Line #13</h4><p name="6bf4" id="6bf4" class="graf graf--p graf-after--h4">This is probably the most important line of code for this algorithm (and the most confusing one as well). Here we are just propagating the effects we introduced, further down to the next row.</p><p name="7001" id="7001" class="graf graf--p graf-after--p">We placed a queen at the <code class="markup--code markup--p-code">current_spot</code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong>and now we want to update our variables <code class="markup--code markup--p-code">column</code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">, </em></strong><code class="markup--code markup--p-code">left_diagonal</code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong>and<strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong><code class="markup--code markup--p-code">right_diagonal</code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong>to contain these changes as we move onto the next row.</p><pre name="eac9" id="eac9" class="graf graf--pre graf-after--p">self.solve((column | current_spot), (left_diagonal | current_spot)&gt;&gt; 1,(right_diagonal | current_spot) &lt;&lt; 1, queens_placed + 1)</pre><p name="8f66" id="8f66" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">NOTE:</strong> <code class="markup--code markup--p-code">a | b</code> means bitwise OR for variables <code class="markup--code markup--p-code">a</code> and <code class="markup--code markup--p-code">b</code>. Also, <code class="markup--code markup--p-code">a &lt;&lt; 1</code> is a left-shit operator. Similarly, <code class="markup--code markup--p-code">a &gt;&gt; 1</code> is the right-shift operator.</p><p name="78a8" id="78a8" class="graf graf--p graf-after--p">So calling <code class="markup--code markup--p-code">(right_diagonal | current_spot) &lt;&lt; 1</code> simply says: combine <code class="markup--code markup--p-code">right_diagonal</code> and <code class="markup--code markup--p-code">current_spot</code> with an OR operation, then move everything in the result to the left by one.</p><p name="db4a" id="db4a" class="graf graf--p graf-after--p">For example‚Ää‚Äî‚Ääsay <code class="markup--code markup--p-code">right_diagonal</code> had value <code class="markup--code markup--p-code">00011100</code>. And say we made the queen occupy the last slot such as the last 1 in the <code class="markup--code markup--p-code">valid_spots</code><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em"> </em></strong>integer <code class="markup--code markup--p-code">00100010</code>.</p><p name="05f2" id="05f2" class="graf graf--p graf-after--p">Then the <code class="markup--code markup--p-code">current_spot</code> would become <code class="markup--code markup--p-code">000000010</code> and OR-ing it with the <code class="markup--code markup--p-code">right_diagonal</code> would give us <code class="markup--code markup--p-code">00011110.</code> We left-shift it to get <code class="markup--code markup--p-code">00111100</code> and that is exactly the effect we want for the right-diagonal.</p><p name="6eba" id="6eba" class="graf graf--p graf-after--p">The right-diagonal is moving from right top to bottom left. Left-shift on the bits produces that effect.</p><p name="7da9" id="7da9" class="graf graf--p graf-after--p">For a greater clarity, try doing this operation on a paper:</p><figure name="0a07" id="0a07" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 358px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 51.2%;"></div><img class="graf-image" data-image-id="1*u0D6tQbzP98BCTD54GfV9A.png" data-width="1176" data-height="602" src="https://cdn-images-1.medium.com/max/800/1*u0D6tQbzP98BCTD54GfV9A.png"></div><figcaption class="imageCaption">Just so you don‚Äôt have to go up the article¬†üòõ</figcaption></figure><p name="7e79" id="7e79" class="graf graf--p graf-after--figure">We start with 0s for all the three variables, meaning that all the positions are available in the first row for placing the queens.</p><p name="9709" id="9709" class="graf graf--p graf-after--p">Now comes the fun part (well, something to amaze you üòÜ), Speed Comparisons.</p><h3 name="cfa5" id="cfa5" class="graf graf--h3 graf-after--p">Stats</h3><p name="15a9" id="15a9" class="graf graf--p graf-after--h3">Let‚Äôs look at the stats for a tool that Google built for solving the N-Queens.</p><figure name="87d3" id="87d3" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 656px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 93.8%;"></div><img class="graf-image" data-image-id="1*ZDMBCDEaUvQmcL1TO-GJDg.png" data-width="1286" data-height="1206" src="https://cdn-images-1.medium.com/max/800/1*ZDMBCDEaUvQmcL1TO-GJDg.png"></div><figcaption class="imageCaption"><a href="https://developers.google.com/optimization/cp/queens" data-href="https://developers.google.com/optimization/cp/queens" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://developers.google.com/optimization/cp/queens</a></figcaption></figure><p name="a179" id="a179" class="graf graf--p graf-after--figure">Following are the stats for the 4 different approaches we discussed for the<br>N-Queens:</p><figure name="726f" id="726f" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 337px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 48.1%;"></div><img class="graf-image" data-image-id="1*3vDf0vC_7O1W-RK94ZS5HQ.png" data-width="1256" data-height="604" src="https://cdn-images-1.medium.com/max/800/1*3vDf0vC_7O1W-RK94ZS5HQ.png"></div><figcaption class="imageCaption">All the times are in¬†ms.</figcaption></figure><figure name="77b7" id="77b7" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 335px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 47.8%;"></div><img class="graf-image" data-image-id="1*-J6QjokBFXvZDOYkTGBTyQ.png" data-width="1254" data-height="600" src="https://cdn-images-1.medium.com/max/800/1*-J6QjokBFXvZDOYkTGBTyQ.png"></div><figcaption class="imageCaption">All the times are in¬†ms.</figcaption></figure><p name="6f09" id="6f09" class="graf graf--p graf-after--figure">The last solution involving bitwise operators clearly performs better than the results reported by the <a href="https://developers.google.com/optimization/cp/queens" data-href="https://developers.google.com/optimization/cp/queens" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Google‚Äôs</a> N-Queens solver. üòÉ</p><p name="e3cd" id="e3cd" class="graf graf--p graf-after--p">Also, an interesting thing to note here is the effect that slight optimization had on the results. Recall the optimization where we converted the <code class="markup--code markup--p-code">is_cell_safe</code>check from an <code class="markup--code markup--p-code">O(N)</code> solution to an <code class="markup--code markup--p-code">O(1)</code> check. This clearly shows us how such small changes can bring about huge performance impacts.</p><p name="b302" id="b302" class="graf graf--p graf-after--p">If you‚Äôve read along till the very end, I‚Äôm sure your algorithmic curiosity has now been satisfied! But hey, this is just the tip of the iceberg üòâ.</p><p name="0f70" id="0f70" class="graf graf--p graf-after--p">I have another post coming up soon where we‚Äôll tackle a problem similar to the N-Queens but with a slight twist.</p><p name="1073" id="1073" class="graf graf--p graf-after--p graf--trailing">Kudos to <a href="https://medium.com/u/3d68fc2a6ecb" data-href="https://medium.com/u/3d68fc2a6ecb" data-anchor-type="2" data-user-id="3d68fc2a6ecb" data-action-value="3d68fc2a6ecb" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Rahul Gupta</a> for his valuable inputs in the code and the article.</p></div></div></section>
</section>
</article></body></html>