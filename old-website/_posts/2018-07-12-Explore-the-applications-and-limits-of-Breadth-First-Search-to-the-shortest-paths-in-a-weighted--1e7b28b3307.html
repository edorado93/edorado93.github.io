---
layout: post
title: Breadth First Search and its application to shortest paths in weighted graphs
comments: True
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Explore the applications and limits of Breadth First Search to the shortest paths in a weighted…</title><style>
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 100%;
        margin: auto;
      }
      section {
        width: 100%;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 100%;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Explore the applications and limits of Breadth First Search to the shortest paths in a weighted…</h1>
</header>
<section data-field="subtitle" class="p-summary">
Do you know the amount of global air traffic in 2017? Do you know what the rise has been for air traffic over the past several years …
</section>
<section data-field="body" class="e-content">
<section name="998b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3be3" id="3be3" class="graf graf--h3 graf--leading graf--title"></h3></div><div class="section-inner sectionLayout--outsetColumn"><figure name="1fed" id="1fed" class="graf graf--figure graf--layoutOutsetCenter graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 1111px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 111.1%;"></div><img class="graf-image" data-image-id="1*Dn4pxbJWrya6g1h0NNhaHw.png" data-width="1768" data-height="1964" src="https://cdn-images-1.medium.com/max/1000/1*Dn4pxbJWrya6g1h0NNhaHw.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="b3eb" id="b3eb" class="graf graf--p graf-after--figure">Do you know the amount of global air traffic in 2017? Do you know what the rise has been for air traffic over the past several years ? Well, lets look at some statistics.</p><figure name="c998" id="c998" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 462px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.10000000000001%;"></div><img class="graf-image" data-image-id="1*-YOA5JTQ68fJCixUUBYQ2A.png" data-width="1444" data-height="954" src="https://cdn-images-1.medium.com/max/800/1*-YOA5JTQ68fJCixUUBYQ2A.png"></div><figcaption class="imageCaption">Source: <a href="https://www.statista.com/statistics/564769/airline-industry-number-of-flights/" data-href="https://www.statista.com/statistics/564769/airline-industry-number-of-flights/" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://www.statista.com/statistics/564769/airline-industry-number-of-flights/</a></figcaption></figure><p name="7616" id="7616" class="graf graf--p graf-after--figure">According to the <a href="https://www.icao.int/Pages/default.aspx" data-href="https://www.icao.int/Pages/default.aspx" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">International Civil Aviation Organization</a> (ICAO), a record 4.1 billion passengers were carried by the aviation industry on scheduled services in 2017. And, the number of flights rose to 37 million globally in 2017.</p><p name="6b4b" id="6b4b" class="graf graf--p graf-after--p">That’s a lot of passengers and a lot of flights occupying the air space on a daily basis across the world. Since there are hundreds and thousands of these flights all around the globe, there are bound to be different routes with multiple stops in between from one place to another.</p><p name="ae31" id="ae31" class="graf graf--p graf-after--p">Every flight has a source and destination of its own and a standard economy seat price associated with it. Let’s leave out the fancy business class tickets and extra leg room and what not!</p><p name="f8e0" id="f8e0" class="graf graf--p graf-after--p">In such a scenario, it is too confusing to choose what flight would be the best one if we want to go from one place to another.</p><p name="723a" id="723a" class="graf graf--p graf-after--p">Let’s see the number of flight options <a href="https://www.studentuniverse.com/?noMoreRedirect=true" data-href="https://www.studentuniverse.com/?noMoreRedirect=true" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">StudentUniverse</a> (provides discounts for students 😜) gives me from Los Angeles to New Delhi.</p><figure name="251c" id="251c" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 644px; max-height: 110px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 17.1%;"></div><img class="graf-image" data-image-id="1*ws_g1WoN2gol45O7xgUf9g.png" data-width="644" data-height="110" src="https://cdn-images-1.medium.com/max/800/1*ws_g1WoN2gol45O7xgUf9g.png"></div><figcaption class="imageCaption">Every flight has a Details hyperlink with it, so we searched for that and found 119 total flights.</figcaption></figure><p name="693c" id="693c" class="graf graf--p graf-after--figure">119 total flights are being offered. Then there appears a pop up on the website saying that there are other websites that might be offering similar flights at even cheaper rates. 😩</p><p name="6cae" id="6cae" class="graf graf--p graf-after--p">So many websites and uncountable flights for just a single source and destination.</p><p name="a366" id="a366" class="graf graf--p graf-after--p">As a developer, if I want to solve this problem, I would build a system to efficiently address the following queries:</p><ul class="postList"><li name="2ad8" id="2ad8" class="graf graf--li graf-after--p">Total number of destinations reachable (with a max number of stops) from my current location, and also list those destinations.<br>One should keep their options open when they want to travel 😃.</li><li name="6c12" id="6c12" class="graf graf--li graf-after--li">It is a known fact (IMO 😉) that a route with multiple stops tends to be a cheaper alternative to direct flights.<br>So, given a source and a destination, we may want to find routes with at least 2 or 3 stops.</li><li name="3f2b" id="3f2b" class="graf graf--li graf-after--li">Most importantly: What is the cheapest route from a given source to a given destination?</li><li name="aff4" id="aff4" class="graf graf--li graf-after--li">And…. We’ll come to this one in the end 🙈.</li></ul><p name="f5a0" id="f5a0" class="graf graf--p graf-after--li">As you might guess, there would be potentially thousands of flights as the output of the first two queries. But we can certainly reduce that by providing some other criteria to lessen the output size. For the scope of this article, let us focus on these original queries themselves.</p><h3 name="b6ca" id="b6ca" class="graf graf--h3 graf-after--p">Modeling the Flight Network as a Graph</h3><p name="0465" id="0465" class="graf graf--p graf-after--h3">It’s pretty clear from the headline of this article that graphs would be involved somewhere, isn’t it?</p><p name="c5f3" id="c5f3" class="graf graf--p graf-after--p">Modeling this problem as a graph traversal problem greatly simplifies it and makes the problem much more tractable. So, as a first step, let us define our graph.</p><p name="bf72" id="bf72" class="graf graf--p graf-after--p">We model the air traffic as a:</p><ul class="postList"><li name="10a8" id="10a8" class="graf graf--li graf-after--p">directed</li><li name="e571" id="e571" class="graf graf--li graf-after--li">possibly cyclic</li><li name="e3f8" id="e3f8" class="graf graf--li graf-after--li">weighted</li><li name="e032" id="e032" class="graf graf--li graf-after--li">forest. <strong class="markup--strong markup--li-strong">G (V, E)</strong></li></ul><p name="07f2" id="07f2" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Directed</strong> because every flight will have a designated source and a destination. These carry a lot of meaning.</p><p name="bce3" id="bce3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Cyclic</strong> because it is very possible to follow a bunch of flights starting from a given location and ending back at the same location.</p><p name="1bd7" id="1bd7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Weighted</strong> because every flight has a cost associated with it which would be the economy class flight ticket for this article.</p><p name="4794" id="4794" class="graf graf--p graf-after--p">And finally, a <strong class="markup--strong markup--p-strong">forest</strong> because we might have multiple connected components. It is not necessary that all the cities in the world have some sort of flight network between them. So, the graph can be disconnected, and hence a forest.</p><p name="f2a0" id="f2a0" class="graf graf--p graf-after--p">The vertices, <strong class="markup--strong markup--p-strong">V</strong>, would be the locations all over the world wherever there are working airports.</p><p name="f4dc" id="f4dc" class="graf graf--p graf-after--p">The edges, <strong class="markup--strong markup--p-strong">E</strong>, would be representative of all the flights constituting the air traffic. An edge from <code class="markup--code markup--p-code">u --&gt; v</code> simply means you have a directed flight from the location / node <code class="markup--code markup--p-code">u</code> to <code class="markup--code markup--p-code">v</code> .</p><figure name="d8fd" id="d8fd" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 1142px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 163.2%;"></div><img class="graf-image" data-image-id="1*EVmPCv1BmJ7A1WMl5P2urQ.png" data-width="1064" data-height="1736" src="https://cdn-images-1.medium.com/max/800/1*EVmPCv1BmJ7A1WMl5P2urQ.png"></div><figcaption class="imageCaption">Sample flight network with the cost labelling for different flights.</figcaption></figure><p name="2a1f" id="2a1f" class="graf graf--p graf-after--figure">Now that we have an idea about how to model the flight network as a graph, let us move on and solve the first common query that a user might have.</p><h3 name="b16d" id="b16d" class="graf graf--h3 graf-after--p">Total Number of Destinations Reachable</h3><p name="f79b" id="f79b" class="graf graf--p graf-after--h3">Who doesn’t like to travel?</p><p name="d09c" id="d09c" class="graf graf--p graf-after--p">As someone who likes to explore different places, you would want to know what all destinations are reachable from your local airport. Again, there would be additional criteria here to reduce the results of this query. But to keep things simple, we will simply try and find all the locations reachable from our local airport.</p><p name="f5c8" id="f5c8" class="graf graf--p graf-after--p">Now that we have a well defined graph, we can apply traversal algorithms to process it.</p><p name="8a59" id="8a59" class="graf graf--p graf-after--p">Starting off from a given point, we can use either <a href="https://en.wikipedia.org/wiki/Breadth-first_search" data-href="https://en.wikipedia.org/wiki/Breadth-first_search" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Breadth First Search</a> (BFS) or <a href="https://en.wikipedia.org/wiki/Depth-first_search" data-href="https://en.wikipedia.org/wiki/Depth-first_search" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Depth First Search</a> (DFS) to explore the graph or the locations reachable from the starting location <strong class="markup--strong markup--p-strong">within a maximum number of stops.</strong> Since this article is all about the breadth first search algorithm, let’s look at how we can use the famous BFS to accomplish this task.</p><p name="7b2e" id="7b2e" class="graf graf--p graf-after--p">We will initialize the BFS queue with the given location as the starting point. We then perform the breadth first traversal, and keep going until the queue is empty or until the maximum number of stops have been exhausted.</p><p name="3d23" id="3d23" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Note: </strong>If you are not familiar with the breadth first search or depth first search, I would recommend going through <a href="https://medium.freecodecamp.org/deep-dive-into-graph-traversals-227a90c6a261" data-href="https://medium.freecodecamp.org/deep-dive-into-graph-traversals-227a90c6a261" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this article</a> before continuing.</p><p name="94b0" id="94b0" class="graf graf--p graf-after--p">Let’s look at the code to initialize our graph data structure. We also need to look at how the BFS algorithm would end up giving us all the destinations reachable from a given source.</p><figure name="ffe4" id="ffe4" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/c0ac66eefc34c3d011c9d5d2ea292716.js"></script><figcaption class="imageCaption">Some Random set of flights with source, destination and their prices.</figcaption></figure><p name="d5b0" id="d5b0" class="graf graf--p graf-after--figure">Now that we have a good idea about how the graph is to be initialized, let’s look at the code for the BFS algorithm.</p><figure name="0fff" id="0fff" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/61d9089e3b7da91c4c528b3bcc736be9.js"></script></figure><p name="7aee" id="7aee" class="graf graf--p graf-after--figure">Performing <code class="markup--code markup--p-code">bfs</code> on the city of Los Angeles would give us the following destinations which are reachable:</p><pre name="436b" id="436b" class="graf graf--pre graf-after--p">{&#39;Chicago&#39;, &#39;France&#39;, &#39;Ireland&#39;, &#39;Italy&#39;, &#39;Japan&#39;, &#39;New Delhi&#39;, &#39;Norway&#39;}</pre><p name="99ac" id="99ac" class="graf graf--p graf-after--pre">That was simple, wasn’t it?</p><p name="c34e" id="c34e" class="graf graf--p graf-after--p">We will look at how we can limit the BFS to a maximum number of stops later on in the article.</p><p name="6fc3" id="6fc3" class="graf graf--p graf-after--p">In case we have a humongous flight network, which we would have in a production scenario, then we would not ideally want to explore all the reachable destinations from a given starting point.</p><p name="b214" id="b214" class="graf graf--p graf-after--p">This is a use case if the flight network is very small or pertains only to a few regions in the United States.</p><p name="62d3" id="62d3" class="graf graf--p graf-after--p">But, for a large network, a more realistic use case would be to find all the flight routes with multiple stops. Let us look at this problem in some more detail and see how we can solve it.</p><h3 name="4906" id="4906" class="graf graf--h3 graf-after--p">Routes with multiple stops</h3><p name="790b" id="790b" class="graf graf--p graf-after--h3">It is a well known fact that more often than not, for a given source and destination, a multi stop trip is cheaper than a direct, non-stop flight.</p><p name="50cb" id="50cb" class="graf graf--p graf-after--p">A lot of times we prefer the direct flight to avoid the layovers. Also because the multi-stop flights do tend to take a lot of time — which we don’t have.</p><p name="129f" id="129f" class="graf graf--p graf-after--p">However, if you don’t have any deadlines approaching and you want to save some bucks (and are comfortable with the multi-stop route that a lot of airlines suggest), then you might actually benefit a lot from something like this.</p><p name="460a" id="460a" class="graf graf--p graf-after--p">Also, you might get to pass through some of the most beautiful locations in the world with some of the most advanced airports which you can enjoy. So, that’s enough motivation as it is.</p><p name="d1f6" id="d1f6" class="graf graf--p graf-after--p">In terms of the graph model that we have been talking about, given a source and a destination, we need to come up with routes with 2 or more stops for a given source and destination.</p><p name="afe9" id="afe9" class="graf graf--p graf-after--p">As an end user, we might not want to see flights in this order for this query:</p><pre name="d2c8" id="d2c8" class="graf graf--pre graf-after--p">[A, C, D, B], 2 stops, $X<br>[A, E, D, C, F, W, G, T, B], 8 stops, $M<br>[A, R, E, G, B], 3 stops, $K<br>[A, Z, X, C, V, B, N, S, D, F, G, H, B, 11 stops, $P</pre><p name="ac18" id="ac18" class="graf graf--p graf-after--pre">I know. Nobody in their right minds would want to go for a flight route with 11 stops. But the point I’m trying to make is that an end user would want symmetry. Meaning that they would want to see all the flights with 2 stops first, then all the flights with 3 stops and so on till maybe a max of, say, 5 stops.</p><p name="3c79" id="3c79" class="graf graf--p graf-after--p">But, all the flight routes with the same number of stops in between should be displayed together. That is a requirement we need to satisfy.</p><p name="4348" id="4348" class="graf graf--p graf-after--p">Let’s look at how we can solve this. So, given the graph of flight networks, a source <code class="markup--code markup--p-code">S</code> and a destination <code class="markup--code markup--p-code">D</code>, we have to perform a level order traversal and report flight routes from <code class="markup--code markup--p-code">S --&gt; D</code> with at least 2 and at most 5 stops in between. This means we have to do a level order traversal until a depth of 7 from the start node <code class="markup--code markup--p-code">S</code> .</p><p name="c933" id="c933" class="graf graf--p graf-after--p">Have a look at the code for solving this problem:</p><figure name="5c38" id="5c38" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/ce915542048558003d4395954ae5aa87.js"></script></figure><p name="af57" id="af57" class="graf graf--p graf-after--figure">This might not be the best way to go about solving this problem at scale — the largest memory constraint would be due to the nodes currently present in the queue.</p><p name="ac62" id="ac62" class="graf graf--p graf-after--p">Since every node or location can have thousands of flights to other destinations in the world, the queue could be humongous if we store actual flight data like this. This is just to demonstrate one of the use cases of the breadth first search algorithm.</p><p name="0365" id="0365" class="graf graf--p graf-after--p">Now, let us just focus on the traversal and look at the way it is done. The traversal algorithm is simple as it is. However, the entire space complexity of the level order traversal comes from the elements in the queue and the size of each element.</p><p name="8978" id="8978" class="graf graf--p graf-after--p">There are multiple ways to implement the algorithm. Also, each of them varies in terms of maximum memory consumed at any given time by the elements in the queue.</p><p name="50ec" id="50ec" class="graf graf--p graf-after--p">We want to see the maximum memory consumed by the queue at any point in time during the level order traversal. Before that, let’s construct a random flight network with random prices.</p><figure name="8dd5" id="8dd5" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/12e604c3328ddfb8544ffbbeeb14349b.js"></script></figure><p name="fe98" id="fe98" class="graf graf--p graf-after--figure">Now let us look at the implementation of level order traversal.</p><figure name="4559" id="4559" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/713b7dc200b6cfb614b96cde4b01a4d1.js"></script></figure><p name="4f33" id="4f33" class="graf graf--p graf-after--figure">This above is the easiest and most straightforward implementation of the level order traversal algorithm.</p><p name="f25b" id="f25b" class="graf graf--p graf-after--p">With every node we add to the queue, we also store the level information and we push a tuple of <code class="markup--code markup--p-code">(node, level)</code> into the queue. So every time we pop an element from the queue, we have the level information attached with the node itself.</p><p name="104f" id="104f" class="graf graf--p graf-after--p">The level information for our use case would mean the number of stops from the source to this location in the flight route.</p><p name="945a" id="945a" class="graf graf--p graf-after--p">It turns out that we can do better as far as memory consumption of the program is concerned. Let us look at a slightly better approach to doing level order traversal.</p><figure name="ffe2" id="ffe2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/752ccbd0cd09818967ca8643874a1ea4.js"></script></figure><p name="a63c" id="a63c" class="graf graf--p graf-after--figure">The idea here is that we don’t store any additional information with the nodes being pushed into the queue. We use a <code class="markup--code markup--p-code">None</code> object to mark the end of a given level. We don’t know the size of any level before hand except for the first level, which just has our <code class="markup--code markup--p-code">source</code> node.</p><p name="af52" id="af52" class="graf graf--p graf-after--p">So, we start the queue with <code class="markup--code markup--p-code">[source, None]</code> and we keep popping elements. Every time we encounter a <code class="markup--code markup--p-code">None</code> element, we know that a level has ended and a new one has started. We push another <code class="markup--code markup--p-code">None</code> to mark the end of this new level.</p><p name="5d28" id="5d28" class="graf graf--p graf-after--p">Consider a very simple graph here, and then we will dry run this through the graph.</p><figure name="566e" id="566e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 759px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 108.4%;"></div><img class="graf-image" data-image-id="1*TYLcK8LGHr2CfeNZ1CBg7w.png" data-width="1336" data-height="1448" src="https://cdn-images-1.medium.com/max/800/1*TYLcK8LGHr2CfeNZ1CBg7w.png"></div></figure><pre name="6769" id="6769" class="graf graf--pre graf-after--figure">**************************************************** LEVEL 0 begins<br>level = 0, queue = [A, None]<br>level = 0, pop, A, push, B, C, queue = [None, B, C]<br>pop None ******************************************* LEVEL 1 begins<br>push None<br>level = 1, queue = [B, C, None]<br>level = 1, pop, B, push, C, D, F, queue = [C, None, C, D, F]<br>level = 1, pop, C, push, D, D (lol!), queue = [None, C, D, F, D, D]<br>pop None ******************************************* LEVEL 2 begins<br>push None<br>level = 2, queue = [C, D, F, D, D, None] .... and so on</pre><p name="6714" id="6714" class="graf graf--p graf-after--pre">I hope this sums up the algorithm pretty well. This certainly is a neat trick to do level order traversal, keep track of the levels, and not encounter too much of a memory concern. This certainly reduces the memory footprint of the code.</p><p name="cc40" id="cc40" class="graf graf--p graf-after--p">Don’t get complacent now thinking this is a great improvement.</p><p name="c7ab" id="c7ab" class="graf graf--p graf-after--p">It is, but you should be asking two questions:</p><ol class="postList"><li name="37cc" id="37cc" class="graf graf--li graf-after--p">How big of an improvement is this?</li><li name="dff9" id="dff9" class="graf graf--li graf-after--li">Can we do better?</li></ol><p name="37ed" id="37ed" class="graf graf--p graf-after--li">I will answer both of these questions now starting with the second question. The answer to that is Yes!</p><p name="c688" id="c688" class="graf graf--p graf-after--p">We can do one better here and completely do away with the need for the <code class="markup--code markup--p-code">None</code> in the queue. The motivation for this approach comes from the previous approach itself.</p><p name="f833" id="f833" class="graf graf--p graf-after--p">If you look closely at the dry run above, you can see that every time we pop a <code class="markup--code markup--p-code">None</code>, one level is finished and the other one is ready for processing. The important thing is that an entire next level exists in the queue at the time of popping of a <code class="markup--code markup--p-code">None</code> . We can make use of this idea of considering the queue size into the traversal logic.</p><p name="d75b" id="d75b" class="graf graf--p graf-after--p">Here is the pseudo code for this improved algorithm:</p><pre name="04b2" id="04b2" class="graf graf--pre graf-after--p">queue = Queue()<br>queue.push(S)<br>level = 0<br>while queue is not empty {<br>      size = queue.size()<br>      // size represents the number of elements in the current level<br>      for i in 1..size {<br>          element = queue.pop()<br>          // Process element here<br>          // Perform a series of queue.push() operations here<br>      level += 1</pre><p name="16b4" id="16b4" class="graf graf--p graf-after--pre">And here is the code for the same.</p><figure name="b9e6" id="b9e6" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/c656c837cfa21115e8f05aaaef0056e9.js"></script></figure><p name="8c97" id="8c97" class="graf graf--p graf-after--figure">The pseudo code is self explanatory. We essentially do away with the need for an extra <code class="markup--code markup--p-code">None</code> element per level and instead make use of the queue’s size to change levels. This would also lead to improvement over the last method, but how much?</p><p name="f0a6" id="f0a6" class="graf graf--p graf-after--p">Have a look at the following Jupyter Notebook to see the memory difference between the three methods.</p><figure name="106a" id="106a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/34dbb527af37ba4d9da8076d9039767c.js"></script></figure><ul class="postList"><li name="2b06" id="2b06" class="graf graf--li graf-after--figure">We track the maximum size of the queue at any time by considering the sum of sizes of individual queue elements.</li><li name="fcd8" id="fcd8" class="graf graf--li graf-after--li">According to Python’s documentation, <code class="markup--code markup--li-code">sys.getsizeof</code> returns the object’s pointer or reference’s size in bytes. So, we saved almost 4.4Kb space <code class="markup--code markup--li-code">(20224 — 15800 bytes)</code> by switching to the <code class="markup--code markup--li-code">None</code> method from the original level order traversal method. This is just the memory savings for this random example, and we went only until the 5th level in the traversal.</li><li name="e30f" id="e30f" class="graf graf--li graf-after--li">The final method only gives an improvement of 16 bytes over the <code class="markup--code markup--li-code">None</code> method. This is because we got rid of just 4 <code class="markup--code markup--li-code">None</code> objects which were being used to mark the 4 levels (apart from the first one) that we processed. Each pointer’s size (pointer to an object) is 4 bytes in Python on a 32 bit system.</li></ul><p name="82a9" id="82a9" class="graf graf--p graf-after--li">Now that we have all these interesting multi-path routes from our source to our destination and highly efficient level order traversal algorithms to solve it, we can look at a more lucrative problem to solve using our very own BFS.</p><p name="eb69" id="eb69" class="graf graf--p graf-after--p">What’s the cheapest flight route from my source to a given destination? This is something everybody would be instantly interested in. I mean who doesn’t want to save some bucks?</p><h3 name="c5b7" id="c5b7" class="graf graf--h3 graf-after--p">Shortest Path from a given source to destination</h3><p name="d7cc" id="d7cc" class="graf graf--p graf-after--h3">There’s not much description to give for the problem statement. We just need to find the shortest path and make the end user happy.</p><p name="b25d" id="b25d" class="graf graf--p graf-after--p">Algorithmically, given a weighted directed graph, we need to find the shortest path from source to destination. Shortest or cheapest would be one and the same thing from the point of the view of the algorithm.</p><p name="e1ea" id="e1ea" class="graf graf--p graf-after--p">We will not go into describing a possible BFS solution to this problem because such a solution would be intractable. Let us look at the graph below to understand why that is the case.</p><figure name="e200" id="e200" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 1032px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 147.5%;"></div><img class="graf-image" data-image-id="1*ZaqHLSc9r19WVqSE_YLAPg.png" data-width="1158" data-height="1708" src="https://cdn-images-1.medium.com/max/800/1*ZaqHLSc9r19WVqSE_YLAPg.png"></div></figure><p name="da53" id="da53" class="graf graf--p graf-after--figure">We say that BFS is the algorithm to use if we want to find the <strong class="markup--strong markup--p-strong">shortest path</strong> in an <a href="https://medium.freecodecamp.org/deep-dive-into-graph-traversals-227a90c6a261" data-href="https://medium.freecodecamp.org/deep-dive-into-graph-traversals-227a90c6a261" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">undirected, unweighted graph</a><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">. </em></strong>The claim for BFS is that the first time a node is discovered during the traversal, that distance from the source would give us the shortest path.</p><p name="28ee" id="28ee" class="graf graf--p graf-after--p">The same cannot be said for a weighted graph. Consider the graph above. If say we were to find the shortest path from the node <code class="markup--code markup--p-code">A</code> to <code class="markup--code markup--p-code">B</code> in the undirected version of the graph, then the shortest path would be the direct link between A and B. So, the shortest path would be of length <code class="markup--code markup--p-code">1</code> and BFS would correctly find this for us.</p><p name="b91f" id="b91f" class="graf graf--p graf-after--p">However, we are dealing with a weighted graph here. So, the first discovery of a node during traversal <strong class="markup--strong markup--p-strong">does not guarantee</strong> the shortest path for that node. For example, in the diagram above, the node <code class="markup--code markup--p-code">B</code> would be discovered initially because it is the neighbor of <code class="markup--code markup--p-code">A</code> and the cost associated with this path (an edge in this case) would be <code class="markup--code markup--p-code">25</code> . But, this is not the shortest path. The shortest path is <code class="markup--code markup--p-code">A --&gt; M --&gt; E --&gt; B</code> of length <code class="markup--code markup--p-code">10</code>.</p><p name="4e90" id="4e90" class="graf graf--p graf-after--p">Breadth first search has no way of knowing if a particular discovery of a node would give us the shortest path to that node. And so, the only possible way for BFS (or DFS) to find the shortest path in a weighted graph is to search the entire graph and keep recording the minimum distance from source to the destination vertex.</p><p name="a88b" id="a88b" class="graf graf--p graf-after--p">This solution is not feasible for a huge network like our flight network that would have potentially thousands of nodes.</p><p name="9441" id="9441" class="graf graf--p graf-after--p">We won’t go into the details of how we can solve this. That is out of scope for this article.</p><p name="6cc2" id="6cc2" class="graf graf--p graf-after--p">What if I told you that BFS is just the right algorithm to find the shortest path in a weighted graph <strong class="markup--strong markup--p-strong">with a slight constraint</strong> ?</p><figure name="f3e3" id="f3e3" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://giphy.com/embed/a5viI92PAF89q/twitter/iframe" width="100%" height="300" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">Source: <a href="https://giphy.com/gifs/reaction-a5viI92PAF89q" data-href="https://giphy.com/gifs/reaction-a5viI92PAF89q" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://giphy.com/gifs/reaction-a5viI92PAF89q</a></figcaption></figure><h3 name="c3c6" id="c3c6" class="graf graf--h3 graf-after--figure">Constrained Shortest Paths</h3><p name="b293" id="b293" class="graf graf--p graf-after--h3">Since the graph we would have for the flight network is humongous, we know that exploring it completely is not really a possibility.</p><p name="46da" id="46da" class="graf graf--p graf-after--p">Consider the problem of shortest paths from the customer’s perspective. When you want to book a flight, these are the following options you ideally consider:</p><ul class="postList"><li name="c75b" id="c75b" class="graf graf--li graf-after--p">It shouldn’t be too long a flight.</li><li name="32cd" id="32cd" class="graf graf--li graf-after--li">It should be under your budget (Very Important).</li><li name="ab5b" id="ab5b" class="graf graf--li graf-after--li">It may have multiple stops but not more than <code class="markup--code markup--li-code">K</code> where <code class="markup--code markup--li-code">K</code> can vary from person to person.</li><li name="a964" id="a964" class="graf graf--li graf-after--li">Finally we have personal preferences which involve things like lounge access, food quality, layover locations, and average leg room.</li></ul><p name="002e" id="002e" class="graf graf--p graf-after--li">The important point to consider here is the third one above: it may have multiple stops, but not more than <code class="markup--code markup--p-code">K</code> where <code class="markup--code markup--p-code">K</code> can vary from person to person.</p><p name="24be" id="24be" class="graf graf--p graf-after--p">A customer wants the cheapest flight route, but they also don’t want say 20 stops in between their source and destination. A customer might be okay with a maximum of 3 stops, or in extreme cases maybe even 4 — but not more than that.</p><p name="7a50" id="7a50" class="graf graf--p graf-after--p">We would want an application that would find out the cheapest flight route with <a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/" data-href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">at most K stops</a> for a given source and destination.</p><figure name="a46b" id="a46b" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 412px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 58.8%;"></div><img class="graf-image" data-image-id="1*4_xEqai9idr89T1L6bHfeQ.png" data-width="2176" data-height="1280" src="https://cdn-images-1.medium.com/max/800/1*4_xEqai9idr89T1L6bHfeQ.png"></div><figcaption class="imageCaption">Source: Leetcode.com</figcaption></figure><p name="fb2d" id="fb2d" class="graf graf--p graf-after--figure">This question from LeetCode has been the primary motivation for me to write this article. I strongly recommend going through the question once and not only relying on the snapshot above.</p><p name="c64f" id="c64f" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“Why would BFS work here?” one might ask. “This is also a weighted graph and the same reason for the failure of BFS that we discussed in the previous section should apply here.” NO!</p><p name="5b01" id="5b01" class="graf graf--p graf-after--p">The number of levels that the search would go to is limited by the value <code class="markup--code markup--p-code">K</code> in the question or in the description provided at the start of section. So, essentially, we would be trying to find the shortest path, but we won’t have to explore the entire graph as such. We will just go up to the level <code class="markup--code markup--p-code">K</code>.</p><p name="2532" id="2532" class="graf graf--p graf-after--p">From a real life scenario, the value of <code class="markup--code markup--p-code">K</code> would be under 5 for any sane traveler 😝.</p><p name="f0ee" id="f0ee" class="graf graf--p graf-after--p">Let us look at the pseudo-code for the algorithm:</p><pre name="5d09" id="5d09" class="graf graf--pre graf-after--p">def bfs(source, destination, K):<br>      min_cost = dictionary representing min cost under K stops for each node reachable from source. <br>      set min_cost of source to be 0<br>      Q = queue()<br>      Q.push(source)<br>      stops = 0<br>      while Q is not empty {<br>           size = Q.size<br>           for i in range 1..size {<br>                 element = Q.pop() <br>                 if element == destination then continue<br>                 for neighbor in adjacency list of element {<br>                        if stops == K and neighbor != destination        then continue  <br>                        if min_cost of neighbor improves, update and add back to the queue.<br>                }<br>           }    <br>           stops ++ <br>      }</pre><p name="4c7a" id="4c7a" class="graf graf--p graf-after--pre">This again is level order traversal and the approach being used here is the one that makes use of the queue’s size at every level. Let us look at a commented version of the code to solve this problem.</p><figure name="6046" id="6046" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/4655b45ae1d93e95390f5bcee80116cf.js"></script></figure><p name="fae8" id="fae8" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Essentially, we keep track of the minimum distance of every node from the given source. The minimum distance for the source would be 0 and +inf for all others initially.</strong></p><p name="7d18" id="7d18" class="graf graf--p graf-after--p">Whenever we encounter a node, we check if the current minimum path length can be improved or not. If it can be improved, that means that we have found an alternate path from source to this vertex with cheaper cost — a cheaper flight route until this vertex. We queue this vertex again so that locations and nodes reachable from this vertex on are updated (may or may not be) as well.</p><p name="6bfa" id="6bfa" class="graf graf--p graf-after--p">The key thing is this:</p><pre name="96b5" id="96b5" class="graf graf--pre graf-after--p"># No need to update the minimum cost if we have already exhausted our K stops. <br>if stops == K and neighbor != dst:<br>    continue</pre><p name="3a15" id="3a15" class="graf graf--p graf-after--pre">So we just popped the a node represented by <code class="markup--code markup--p-code">element</code> in the code and <code class="markup--code markup--p-code">neighbor</code> can either be a destination or a random other node. If we have already exhausted our <code class="markup--code markup--p-code">K</code> stops with the <code class="markup--code markup--p-code">element</code> being the <code class="markup--code markup--p-code">Kth</code> stop, then we shouldn’t process and update (possibly) the minimum distance for <code class="markup--code markup--p-code">neighbor</code>. This would violate our maximum <code class="markup--code markup--p-code">K</code> stops condition in that case.</p><p name="4518" id="4518" class="graf graf--p graf-after--p">As it turns out, I solved this problem originally using Dynamic Programming and it took around 165ms to run on the LeetCode platform. I ran using BFS and it was blazing fast with just 45ms to execute. Motivation enough to write this article for you guys.</p><p name="5fbd" id="5fbd" class="graf graf--p graf-after--p graf--trailing">I hope you were able to derive some benefit from this article on Breadth First Search and some of its applications. The major focus was to showcase its application to shortest paths in a weighted graph under some constraints 😃.</p></div></div></section>
</section>
</article></body></html>
