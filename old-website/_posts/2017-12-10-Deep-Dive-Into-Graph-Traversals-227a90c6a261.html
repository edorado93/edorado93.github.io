---
layout: post
title: "Deep Dive Into Graph Traversals"
comments: True
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Deep Dive Into Graph Traversals</title><style>
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 100%;
        margin: auto;
      }
      section {
        width: 100%;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 100%;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Deep Dive Into Graph Traversals</h1>
</header>
<section data-field="subtitle" class="p-summary">
There are over 2.07 billion monthly active Facebook Users worldwide as of Q3 2017. The most important aspect of the Facebook network is the…
</section>
<section data-field="body" class="e-content">
<section name="9d62" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a9f9" id="a9f9" class="graf graf--h3 graf--leading graf--title"></h3></div><div class="section-inner sectionLayout--fullWidth"><figure name="3088" id="3088" class="graf graf--figure graf--layoutFillWidth graf-after--h3"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 74.2%;"></div><img class="graf-image" data-image-id="1*Pebp8Cds-RLs417qaOS_8A.png" data-width="2747" data-height="2039" src="https://cdn-images-1.medium.com/max/2000/1*Pebp8Cds-RLs417qaOS_8A.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="61e6" id="61e6" class="graf graf--p graf-after--figure">There are over 2.07 billion monthly active Facebook Users worldwide as of Q3 2017. The most important aspect of the Facebook network is the social engagement between users. The more friends a user has, the more engaging the conversations become via comments on posts, messaging etc. If you’ve used Facebook fairly regularly, you must be knowing about the Friends Recommendation feature.</p><p name="11b0" id="11b0" class="graf graf--p graf-after--p">Facebook recommends a set of people that we can add as friends. Most of the times, these are people we’ve never heard of before. But still, Facebook thinks that we should add them. The question is: <strong class="markup--strong markup--p-strong">how does Facebook come up with a set of recommendations for a specific person</strong>?</p><p name="1973" id="1973" class="graf graf--p graf-after--p">One way to do this is based on mutual friends. eg:- If a user A and C don’t know each other, but they have a mutual friend B, then probably A and C should be friends too. What if A and C have 2 mutual friends and A and D have 3 mutual friends? How will the ordering be for suggestions?</p><p name="bcd2" id="bcd2" class="graf graf--p graf-after--p">In this case, it seems pretty obvious to suggest D over C to A because they have more mutual friends and are more likely to get connected.</p><p name="4cfc" id="4cfc" class="graf graf--p graf-after--p">However, two people might not always have mutual friends, but they might have common 2nd-degree or 3rd-degree connections.</p><h3 name="8184" id="8184" class="graf graf--h3 graf-after--p">Nth Degree Connections</h3><ul class="postList"><li name="414f" id="414f" class="graf graf--li graf-after--h3">A and B are friends. <strong class="markup--strong markup--li-strong">(0 degree)</strong></li><li name="66ca" id="66ca" class="graf graf--li graf-after--li">A and B are <strong class="markup--strong markup--li-strong">1st-degree</strong> friends means they have a mutual friend.</li><li name="ce5c" id="ce5c" class="graf graf--li graf-after--li">A and B are <strong class="markup--strong markup--li-strong">2nd-degree </strong>friends if they have a friend, who is a 1st-degree friend with the other person. eg:- A — C — D — B, then A and B are 2nd-degree friends.</li><li name="caa8" id="caa8" class="graf graf--li graf-after--li">Similarly, A and B are <strong class="markup--strong markup--li-strong">Nth degree </strong>friends if they have N connections in between. eg:- A — X1 — X2 — X3….. — XN — B.</li></ul><p name="3d40" id="3d40" class="graf graf--p graf-after--li">Looking at this approach for the recommendation, we need to be able to find the degree of friendship that two given users share on Facebook.</p><h3 name="8bcb" id="8bcb" class="graf graf--h3 graf-after--p">Enter Graph Traversals</h3><p name="1e59" id="1e59" class="graf graf--p graf-after--h3">Now that we know how Friend Recommendations can be made, let’s restate this problem so that we can look at it from an algorithmic perspective.</p><p name="d0ae" id="d0ae" class="graf graf--p graf-after--p">Let’s imagine an undirected graph of all the users on Facebook<strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">, </em></strong>where vertices <strong class="markup--strong markup--p-strong">V </strong>represent the users and edges <strong class="markup--strong markup--p-strong">E </strong>represent friendships. In other words: if users A and B are friends on Facebook, there is an edge between vertices A and B. The challenge is to find out the degree of connection between any two users.</p><p name="e414" id="e414" class="graf graf--p graf-after--p">More formally, we need to see the shortest distance between two nodes in an undirected, unweighted graph.</p><figure name="0ddd" id="0ddd" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 600px; max-height: 600px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 100%;"></div><img class="graf-image" data-image-id="1*KoGmDyC-0hlueEpG_0HJNw.png" data-width="600" data-height="600" src="https://cdn-images-1.medium.com/max/800/1*KoGmDyC-0hlueEpG_0HJNw.png"></div></figure><p name="d748" id="d748" class="graf graf--p graf-after--figure">Consider two vertices in this undirected graph A and C. There are two different paths for reaching C:</p><p name="93bb" id="93bb" class="graf graf--p graf-after--p">1. A → B → C and <br>2. A → G →F → E →D →C</p><p name="01b3" id="01b3" class="graf graf--p graf-after--p">Clearly, we want to take the smallest path when trying to see the degree of connection between two people on the social network.</p><p name="d471" id="d471" class="graf graf--p graf-after--p">So far so good.</p><p name="3c3a" id="3c3a" class="graf graf--p graf-after--p">Before proceeding, let’s look at the complexity of this problem. As stated before, Facebook has around 2.07 billion users as of Q3 2017. That means our graph will have around 2.07 billion nodes and at least (2.07 billion — 1) edges (if every person has at least one friend)<strong class="markup--strong markup--p-strong">.</strong></p><p name="e495" id="e495" class="graf graf--p graf-after--p">This is a huge scale to solve this problem on. Additionally, we also saw that there might be multiple paths to reach from a given source vertex to a destination vertex in the graph and we want the shortest one to solve our problem.</p><p name="19f0" id="19f0" class="graf graf--p graf-after--p">We will look at two classic graph traversal algorithms to solve our problem:</p><p name="4d15" id="4d15" class="graf graf--p graf-after--p">1. Depth First Search and <br>2. Breadth First Search.</p><h3 name="cb5b" id="cb5b" class="graf graf--h3 graf-after--p">Depth First Search</h3><p name="3b08" id="3b08" class="graf graf--p graf-after--h3">Imagine that you get stuck in a maze like this.</p><figure name="a3e4" id="a3e4" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 711px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 101.49999999999999%;"></div><img class="graf-image" data-image-id="1*QY2TR83UiZlqXF1mRes2rA.png" data-width="2330" data-height="2365" src="https://cdn-images-1.medium.com/max/800/1*QY2TR83UiZlqXF1mRes2rA.png"></div></figure><p name="9433" id="9433" class="graf graf--p graf-after--figure">You have to get out somehow. There might be multiple routes from your starting position to the exit. The natural approach to getting out of the maze is to try all the paths.</p><p name="821f" id="821f" class="graf graf--p graf-after--p">Let’s say you have two choices at the point where you are currently standing. Obviously, you don’t know which one leads out of the maze. So you decide to make the first choice and move onwards in the maze.</p><p name="739d" id="739d" class="graf graf--p graf-after--p">You keep making moves and you keep moving forward and you hit a dead end. Now you would ideally want to try a different path, and so you <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">backtrack </em></strong>to a previous checkpoint where you made one of the choices and then you try a new one i.e. a different path this time.</p><p name="5475" id="5475" class="graf graf--p graf-after--p">You keep doing this until you find the exit.</p><p name="169e" id="169e" class="graf graf--p graf-after--p">Recursively trying out a specific path and backtracking are the two components forming the <strong class="markup--strong markup--p-strong">Depth First Search algorithm </strong>(DFS).</p><p name="25af" id="25af" class="graf graf--p graf-after--p">If we model the maze problem as a graph, the vertices would represent the individual’s position on the maze and directed edges between two nodes would represent a single move from one position to another position. Using DFS, the individual would try all possible routes until the exit is found.</p><p name="5e83" id="5e83" class="graf graf--p graf-after--p">Here is a sample pseudo-code for the same.</p><pre name="3783" id="3783" class="graf graf--pre graf-after--p">1  <strong class="markup--strong markup--pre-strong">procedure</strong> DFS(<em class="markup--em markup--pre-em">G</em>,<em class="markup--em markup--pre-em">v</em>):<br>2      label <em class="markup--em markup--pre-em">v</em> as discovered<br>3      <strong class="markup--strong markup--pre-strong">for all</strong> edges from <em class="markup--em markup--pre-em">v</em> to <em class="markup--em markup--pre-em">w</em> <strong class="markup--strong markup--pre-strong">in</strong> <em class="markup--em markup--pre-em">G</em>.adjacentEdges(<em class="markup--em markup--pre-em">v</em>) <strong class="markup--strong markup--pre-strong">do</strong><br>4          <strong class="markup--strong markup--pre-strong">if</strong> vertex <em class="markup--em markup--pre-em">w</em> is not labeled as discovered <strong class="markup--strong markup--pre-strong">then</strong><br>5              recursively call DFS(<em class="markup--em markup--pre-em">G</em>,<em class="markup--em markup--pre-em">w</em>)</pre><p name="ce55" id="ce55" class="graf graf--p graf-after--pre">For a deeper dive into this algorithm, check out :-</p><div name="8e43" id="8e43" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13" data-href="https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13"><strong class="markup--strong markup--mixtapeEmbed-strong">Deep Dive Through A Graph: DFS Traversal</strong><br><em class="markup--em markup--mixtapeEmbed-em">For better or for worse, there’s always more than one way to do something. Luckily for us, in the world of software and…</em>medium.com</a></div><p name="1636" id="1636" class="graf graf--p graf-after--mixtapeEmbed">Time Complexity: O(V + E)</p><h3 name="1a5d" id="1a5d" class="graf graf--h3 graf-after--p">Breadth First Search</h3><p name="7eac" id="7eac" class="graf graf--p graf-after--h3">Imagine a contagious disease gradually spreading across a region. Every day, the people who have the illness infect new people they come into physical contact with. In this way, the disease is doing a sort of <strong class="markup--strong markup--p-strong">breadth-first-search</strong>(BFS) over the population. The “queue” is the set of people who have just been infected. The graph is the physical contact network of the region.</p><p name="88f3" id="88f3" class="graf graf--p graf-after--p">Imagine you need to simulate the spread of the disease through this network. The root node of the search is patient zero, the first known sufferer of the disease. You start off with just them with the disease, and no one else.</p><p name="2244" id="2244" class="graf graf--p graf-after--p">Now you iterate over the people they are in contact with. Some will catch the disease. Now iterate over all of them. Give the people they’re in contact with the disease too, unless they’ve already had it. Keep going until you’ve infected everyone, or you’ve infected your target. Then you’re done. That’s how breadth-first-search works.</p><figure name="02cd" id="02cd" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 418px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 59.8%;"></div><img class="graf-image" data-image-id="1*iY5TrjCxKqTjA6mq-gR8pg.png" data-width="1288" data-height="770" src="https://cdn-images-1.medium.com/max/800/1*iY5TrjCxKqTjA6mq-gR8pg.png"></div></figure><p name="b6b4" id="b6b4" class="graf graf--p graf-after--figure">The BFS search algorithm explores vertices layer by layer starting at the very first vertex and only moving on to the next layer once all vertices on the current layer have been processed.</p><p name="18e1" id="18e1" class="graf graf--p graf-after--p">Here is a sample pseudo-code for BFS.</p><pre name="2975" id="2975" class="graf graf--pre graf-after--p">1   <strong class="markup--strong markup--pre-strong">procedure BFS(</strong><em class="markup--em markup--pre-em">G, v</em><strong class="markup--strong markup--pre-strong">):<br></strong>2       q = Queue()<br>3       q.<strong class="markup--strong markup--pre-strong">enqueue(v)</strong><br>4       <strong class="markup--strong markup--pre-strong">while</strong> q is not empty:<br>5            v = q.dequeue()<br>6            if v is <strong class="markup--strong markup--pre-strong">not visited:<br></strong>7               mark v as visited (// Process the node)<br>8               <strong class="markup--strong markup--pre-strong">for all</strong> edges from <em class="markup--em markup--pre-em">v</em> to <em class="markup--em markup--pre-em">w</em> <strong class="markup--strong markup--pre-strong">in</strong> <em class="markup--em markup--pre-em">G</em>.adjacentEdges(<em class="markup--em markup--pre-em">v</em>) <strong class="markup--strong markup--pre-strong">do<br></strong>9                    q.enqueue(w)</pre><p name="be64" id="be64" class="graf graf--p graf-after--pre">For a deeper understanding of BFS, look into <a href="https://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255" data-href="https://medium.com/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255" class="markup--anchor markup--p-anchor" target="_blank">this article</a>.</p><p name="bd47" id="bd47" class="graf graf--p graf-after--p">Time Complexity: O(V + E)</p><h3 name="5c65" id="5c65" class="graf graf--h3 graf-after--p">Shortest Paths</h3><p name="0f0e" id="0f0e" class="graf graf--p graf-after--h3">Let’s move forward and solve our original problem: finding the shortest path between two given vertices in an undirected graph.</p><p name="797d" id="797d" class="graf graf--p graf-after--p">Looking at the time complexities of the two algorithms, we can’t really make out the difference between the two for this problem. Both the algorithms will find a path (or rather the shortest path) to our destination from the given source.</p><p name="f42d" id="f42d" class="graf graf--p graf-after--p">Let’s look at the following example.</p><figure name="be7b" id="be7b" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 583px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 83.39999999999999%;"></div><img class="graf-image" data-image-id="1*YQ1t6ZVjdR9rNvpegFC4Qg.png" data-width="2000" data-height="1667" src="https://cdn-images-1.medium.com/max/800/1*YQ1t6ZVjdR9rNvpegFC4Qg.png"></div></figure><p name="fdeb" id="fdeb" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Suppose we want to find out the shortest path from the node 8 to 10</strong>. Let’s look at the nodes that DFS and BFS explore before reaching the destination.</p><h4 name="d3ba" id="d3ba" class="graf graf--h4 graf-after--p">DFS</h4><ul class="postList"><li name="c48c" id="c48c" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Process</strong> 8 → <strong class="markup--strong markup--li-strong">Process</strong> 3 → <strong class="markup--strong markup--li-strong">Process</strong> 1.</li><li name="b7f3" id="b7f3" class="graf graf--li graf-after--li">Backtrack to 3.</li><li name="01d2" id="01d2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Process</strong> 6 → <strong class="markup--strong markup--li-strong">Process</strong> 4.</li><li name="6043" id="6043" class="graf graf--li graf-after--li">Backtrack to 6.</li><li name="86fe" id="86fe" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Process</strong> 7.</li><li name="2dd9" id="2dd9" class="graf graf--li graf-after--li">Backtrack to 6 → Backtrack to 3 → Backtrack to 8.</li><li name="6238" id="6238" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Process 10</strong>.</li></ul><p name="fd6e" id="fd6e" class="graf graf--p graf-after--li">A total of 7 nodes are being processed here before the destination is reached. Now let’s look at how BFS does things.</p><h4 name="14e9" id="14e9" class="graf graf--h4 graf-after--p">BFS</h4><ul class="postList"><li name="0235" id="0235" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Process</strong> 8 → Enqueue 3, 10</li><li name="cfb1" id="cfb1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Process</strong> 3 → Enqueue 1,6</li><li name="f664" id="f664" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Process</strong> 10.</li></ul><p name="b666" id="b666" class="graf graf--p graf-after--li">Woah, that was fast! Just 3 nodes had to be processed and we were at our destination.</p><p name="8908" id="8908" class="graf graf--p graf-after--p">The explanation for this speedup that we can see in BFS and not in DFS is because DFS takes up a specific path and goes till the very end i.e. until it hits a dead end and then backtracks.</p><p name="e75e" id="e75e" class="graf graf--p graf-after--p">This is the major downfall of the DFS algorithm. It might have to expand 1000s of levels (in a huge network like that of Facebook, just because it selected a bad path to process in the very beginning) before reaching the path containing our destination. BFS doesn’t face this problem and hence is much faster for our problem.</p><p name="e4c2" id="e4c2" class="graf graf--p graf-after--p">Additionally, even if DFS finds out the destination, we cannot be sure that the path taken by DFS is the shortest one. There might be other paths as well.</p><p name="afee" id="afee" class="graf graf--p graf-after--p">That means that in any case, for the shortest paths problem, DFS would have to span the entire graph to get the shortest path.</p><p name="dd66" id="dd66" class="graf graf--p graf-after--p">In the case of BFS, however, the first occurrence of the destination node ensures that it is the one at the shortest distance from the source.</p><h3 name="6f30" id="6f30" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="d7d6" id="d7d6" class="graf graf--p graf-after--h3">So far we discussed the problem of Friends Recommendation by Facebook and we boiled it down to the problem of finding the degree of connections between two users in the network graph.</p><p name="ca37" id="ca37" class="graf graf--p graf-after--p">Then we discussed two interesting Graph Traversal algorithms that are very commonly used. Finally, we looked at which algorithm performs the best for solving our problem.</p><p name="411a" id="411a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Breadth First Search is the algorithm you want to use if you have to find the shortest distance between two nodes in an undirected, unweighted graph.</strong></p><p name="8479" id="8479" class="graf graf--p graf-after--p">Let’s look at <a href="https://leetcode.com/problems/minimum-genetic-mutation/description/" data-href="https://leetcode.com/problems/minimum-genetic-mutation/description/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this fun problem</a> to depict the difference between the two algorithms.</p><p name="a4be" id="a4be" class="graf graf--p graf-after--p">Assuming that you’ve read the problem statement carefully, let’s try and model this as a graph problem in the first place.</p><p name="8a0b" id="8a0b" class="graf graf--p graf-after--p">Let all possible strings become nodes in the graph and we have an edge between two vertices if they have a single mutation between them.</p><p name="e6d1" id="e6d1" class="graf graf--p graf-after--p">Easy, right?</p><p name="6e52" id="6e52" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">We are given a starting string (read source vertext) eg:- “AACCGGTT” and we have to reach the destination string (read destination vertex) “AACCGGTA” in minimum number of mutations (read minimum number of steps) such that all intermediate strings (nodes) should belong to the given word bank.</em></p><p name="58a8" id="58a8" class="graf graf--p graf-after--p">Try and solve this problem on your own before looking at the solution below.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="c369" id="c369" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 505px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 50.5%;"></div><img class="graf-image" data-image-id="1*1jpQ5HpQwY96J3-JxuhcYw.png" data-width="2606" data-height="1316" src="https://cdn-images-1.medium.com/max/1000/1*1jpQ5HpQwY96J3-JxuhcYw.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="1cc6" id="1cc6" class="graf graf--p graf-after--figure">If you try to solve it using DFS, you will surely come up with a solution, but there is a test case(s) that will exceed the allotted time limit on the LeetCode platform. That’s because of the problem described before as to why DFS takes so long (process 7 nodes as opposed to 3 in BFS) to reach the destination vertex.</p><p name="2555" id="2555" class="graf graf--p graf-after--p">Hope you got the main idea behind the two main graph traversals, and the difference between them when the application is shortest paths in an undirected unweighted graph.</p><p name="a3ec" id="a3ec" class="graf graf--p graf-after--p graf--trailing">Please recommend (❤) this post if you think this may be useful for someone!</p></div></div></section>
</section>
</article></body></html>
