---
layout: post
title: "Change the signs: how to use dynamic programming to solve a competitive programming question"
comments: True
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Change the signs: how to use dynamic programming to solve a competitive programming question</title><style>
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 100%;
        margin: auto;
      }
      section {
        width: 100%;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 100%;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Change the signs: how to use dynamic programming to solve a competitive programming question</h1>
</header>
<section data-field="subtitle" class="p-summary">
If you’re a competitive programmer like I am, one of the best feelings in the world is seeing your program getting accepted on first try on…
</section>
<section data-field="body" class="e-content">
<section name="b4c0" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3e6d" id="3e6d" class="graf graf--h3 graf--leading graf--title"></h3></div><div class="section-inner sectionLayout--fullWidth"><figure name="8d9d" id="8d9d" class="graf graf--figure graf--layoutFillWidth graf-after--h3"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 78.4%;"></div><img class="graf-image" data-image-id="1*kdC2W2WKEjPIG1pRCk0qmg.png" data-width="2046" data-height="1604" data-is-featured="true" src="https://cdn-images-1.medium.com/max/2000/1*kdC2W2WKEjPIG1pRCk0qmg.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="2645" id="2645" class="graf graf--p graf-after--figure">If you’re a competitive programmer like I am, one of the best feelings in the world is seeing your program getting accepted on first try on one of the most famous programming platforms, <a href="https://www.codechef.com/" data-href="https://www.codechef.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CodeChef</a>.</p><p name="86b0" id="86b0" class="graf graf--p graf-after--p">I was an avid competitive programmer during undergrad, and then lost touch with it when working as a developer @Hike. However, I recently started out into this adventurous world of programming again, all thanks to my friend <a href="https://medium.com/u/842b783318b8" data-href="https://medium.com/u/842b783318b8" data-anchor-type="2" data-user-id="842b783318b8" data-action-value="842b783318b8" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Divya Godayal</a>.</p><p name="d398" id="d398" class="graf graf--p graf-after--p">The <a href="https://www.codechef.com/MAY18" data-href="https://www.codechef.com/MAY18" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CodeChef May 2018 Long Challenge</a> ended about an hour ago, and I decided to write this article as a post describing one of the questions in the competition.</p><p name="87dc" id="87dc" class="graf graf--p graf-after--p">Without wasting any more time, let’s get to it.</p><figure name="d04c" id="d04c" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 955px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 136.4%;"></div><img class="graf-image" data-image-id="1*bY14HmJRTsQME9jEE3RH6Q.png" data-width="1284" data-height="1752" src="https://cdn-images-1.medium.com/max/800/1*bY14HmJRTsQME9jEE3RH6Q.png"></div></figure><h3 name="0135" id="0135" class="graf graf--h3 graf-after--figure">Unravelling the Problem Statement</h3><p name="c48a" id="c48a" class="graf graf--p graf-after--h3">Let’s look at some examples to better understand what the problem statement is asking for.</p><p name="918d" id="918d" class="graf graf--p graf-after--p">Consider the following number sequence.</p><pre name="2089" id="2089" class="graf graf--pre graf-after--p">4 3 1 2</pre><p name="7c43" id="7c43" class="graf graf--p graf-after--pre">Now the question asks us to perform a certain operation (possibly 0 times, leaving the sequence unchanged). We can negate a certain subsequence of numbers and get a new sequence.</p><pre name="e795" id="e795" class="graf graf--pre graf-after--p">-4 3 1 2<br>4 -3 1 -2<br>4 3 -1 2<br>4 3 1 -2<br>-4 -3 1 2 etc.</pre><p name="ad56" id="ad56" class="graf graf--p graf-after--pre">The question says that the resulting sequence should satisfy the following constraint:</p><p name="3130" id="3130" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The sum of elements of any substring with length greater than 1 is strictly positive.</strong></p><p name="d600" id="d600" class="graf graf--p graf-after--p">Clearly, the following sequences are not valid:</p><pre name="3029" id="3029" class="graf graf--pre graf-after--p">-4 3 1 2<br>4 -3 1 -2 <br>4 3 1 -2 <br>-4 -3 1 2 <br>-4 -3 -1 -2<br>4 3 -1 -2</pre><p name="b53d" id="b53d" class="graf graf--p graf-after--pre">We only have 2 valid subsequences that can be obtained by performing the operation mentioned above. <strong class="markup--strong markup--p-strong">Note:</strong> we haven’t written down all the possible subsequences. That would be 2^n, that is 16 in this case, because for every number we have two options. Either to negate it, or not.</p><p name="e93e" id="e93e" class="graf graf--p graf-after--p">So the two valid sequences are:</p><pre name="2e78" id="2e78" class="graf graf--pre graf-after--p">4 3 1 2</pre><p name="80d5" id="80d5" class="graf graf--p graf-after--pre">and</p><pre name="55db" id="55db" class="graf graf--pre graf-after--p">4 3 -1 2</pre><p name="22d4" id="22d4" class="graf graf--p graf-after--pre">The original sequence would always be one of the valid sequences as all the numbers in it are positive.</p><p name="681f" id="681f" class="graf graf--p graf-after--p">Now the question asks us to find the sequence with the minimum sum. So for the example we have considered, the sequence required would be <code class="markup--code markup--p-code">4 3 -1 2</code> .</p><h3 name="dafc" id="dafc" class="graf graf--h3 graf-after--p">Would Greedy Work?</h3><p name="12da" id="12da" class="graf graf--p graf-after--h3">A greedy approach in this question would be that if it is possible to negate a number while satisfying the given constraints, then we should negate that number. This approach however, would not always give the right results. Consider the following example.</p><pre name="4710" id="4710" class="graf graf--pre graf-after--p">4 1 3 2</pre><p name="7099" id="7099" class="graf graf--p graf-after--pre">Here, it is possible to have these three valid sets of numbers:</p><pre name="ae90" id="ae90" class="graf graf--pre graf-after--p">4 1 3 2           4 -1 3 2           4 1 3 -2</pre><p name="7b1a" id="7b1a" class="graf graf--p graf-after--pre">Clearly, both the numbers 2 and 1 can be negated. But not both of them at the same time. If we negate a number greedily — that is, if a number can be negated, then we negate it — then it is possible that we might end up negating the number 1. Then you won’t be able to negate the number 2. This would give us a suboptimal solution.</p><p name="616b" id="616b" class="graf graf--p graf-after--p">So this Greedy approach would not work here. We have to <strong class="markup--strong markup--p-strong">“try out a specific choice of whether to negate or not for a number and see what choice gives us the optimal solution”<em class="markup--em markup--p-em">.</em></strong></p><p name="1730" id="1730" class="graf graf--p graf-after--p">This smells like Dynamic Programming.</p><h3 name="175d" id="175d" class="graf graf--h3 graf-after--p">Good ol’ Dynamic Programming</h3><p name="5daa" id="5daa" class="graf graf--p graf-after--h3">One of the most interesting algorithmic techniques out there, and possibly one of the most dreaded, is dynamic programming. This is the technique we are going to use to solve this particular problem.</p><p name="9611" id="9611" class="graf graf--p graf-after--p">Two of the most important steps in any dynamic programming problem are:</p><ol class="postList"><li name="5259" id="5259" class="graf graf--li graf-after--p">Identifying the recurrent relation.</li><li name="5101" id="5101" class="graf graf--li graf-after--li">Figuring out what to <a href="https://www.interviewcake.com/concept/java/memoization" data-href="https://www.interviewcake.com/concept/java/memoization" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">memoize</strong></a><strong class="markup--strong markup--li-strong">. (not memoRize :P)</strong></li></ol><p name="acc3" id="acc3" class="graf graf--p graf-after--li">The DP-based approach here is divided into two basic parts.</p><ul class="postList"><li name="5016" id="5016" class="graf graf--li graf-after--p">One is the main recursion that we use to find out the <strong class="markup--strong markup--li-strong">minimum sum of the final set</strong>. Note, the dynamic programming is not directly used to obtain the final set, just the sum of the final set of numbers. So our dynamic programming approach would correctly find out the sum for the example given above as 8. <code class="markup--code markup--li-code">4 + 3 + (-1) + 2 = 8</code> .</li><li name="87c5" id="87c5" class="graf graf--li graf-after--li">What we actually need is the final modified set of numbers where some (possibly none) of the numbers are negated. We use the concept of a <strong class="markup--strong markup--li-strong">parent pointer</strong> and <strong class="markup--strong markup--li-strong">backtracking</strong> to find out the actual set of numbers.</li></ul><p name="0200" id="0200" class="graf graf--p graf-after--li">Let’s move onto our recursion relation for our dynamic programming approach.</p><p name="a109" id="a109" class="graf graf--p graf-after--p">Before describing the recursive relation an important observation to make here is that if a number has been negated, <strong class="markup--strong markup--p-strong">then any adjacent number to it can not be negative</strong>. That is,<strong class="markup--strong markup--p-strong"> </strong>two adjacent numbers cannot be negative as that would give a substring of length 2 whose sum is negative, and that is not allowed according to the question.</p><p name="4f80" id="4f80" class="graf graf--p graf-after--p">For the recurrence relation, we need two variables. One is the index number of where we are in the array, and one is a boolean value that tells us if the previous number (one left to the previous number) is negated or not. So if the current index is <code class="markup--code markup--p-code">i</code>, then the boolean value would tell us if the number at <code class="markup--code markup--p-code">i — 2 </code>was negated or not. You will know the importance of this boolean variable in the next paragraph.</p><p name="481e" id="481e" class="graf graf--p graf-after--p">We need to know in <code class="markup--code markup--p-code">O(1)</code> if a number <strong class="markup--strong markup--p-strong">can</strong> be negated or not. Since we are following a recursion with memoization-based solution, whenever we are at an index <code class="markup--code markup--p-code">i </code>in the recursion, we are sure that the numbers to the right (<code class="markup--code markup--p-code">i+ 1</code> onwards) have not been processed up to this point. This means that all of them are still positive.</p><p name="0b53" id="0b53" class="graf graf--p graf-after--p">The choice of whether the number at index <code class="markup--code markup--p-code">i </code>can be negated is dependent upon the right hand side (if there is one) and the left hand side (if there is one). The right hand side is easy. All we need to check is if</p><pre name="a0cf" id="a0cf" class="graf graf--pre graf-after--p">number[i] &lt; number[i + 1]</pre><p name="2a43" id="2a43" class="graf graf--p graf-after--pre">because if this is not true, then adding these two would give a negative value for the substring <code class="markup--code markup--p-code">[i, i + 1]</code> thus making it an invalid operation.</p><p name="9678" id="9678" class="graf graf--p graf-after--p">Now comes the tricky part. We need to see if negating the number at <code class="markup--code markup--p-code">i </code>will cause a substring of negative sum to the left or not. When we reach the index <code class="markup--code markup--p-code">i </code>in our recursion, we have already processed the numbers before it, and some might have been negated as well.</p><p name="1942" id="1942" class="graf graf--p graf-after--p">So say we have this set of numbers <code class="markup--code markup--p-code">4 1 2 1</code> and we had negated the first <code class="markup--code markup--p-code">1</code> and we are now processing the last number ( <code class="markup--code markup--p-code">1</code> ).</p><pre name="94c4" id="94c4" class="graf graf--pre graf-after--p">4 -1 2 [1]</pre><p name="a361" id="a361" class="graf graf--p graf-after--pre">The last number in square brackets is the one we are processing right now. As far as the right hand side is concerned, since there is none, we can negate it. We need to check if negating this 1 at index 3 (0 based indexing) would cause any substring to the left of ≤ 0 sum. As you can see, it will produce such a substring.</p><pre name="73ed" id="73ed" class="graf graf--pre graf-after--p">-1 2 -1</pre><p name="c6d2" id="c6d2" class="graf graf--p graf-after--pre">This substring would have a 0 sum, and that is invalid according to the question. After negating a subsequence of numbers, the substrings in the final set should have a sum which is strictly positive. All the substrings of length &gt; 1.</p><p name="6932" id="6932" class="graf graf--p graf-after--p">We cannot apply the following approach here directly:</p><pre name="1698" id="1698" class="graf graf--pre graf-after--p">if number[i] &lt; number[i - 1], then it is good to go on negation.</pre><p name="0d94" id="0d94" class="graf graf--p graf-after--pre">because, although <code class="markup--code markup--p-code">1 &lt; 2</code> , if we negate that last 1 as well we will have an invalid set of numbers as seen above. So this simple approach or check won’t work here.</p><p name="e3ec" id="e3ec" class="graf graf--p graf-after--p">Here comes the boolean variable which tells us if, given an index <code class="markup--code markup--p-code">i</code>, the number at <code class="markup--code markup--p-code">i — 2 </code>was negated or not. Consider the two scenarios.</p><ul class="postList"><li name="cfc9" id="cfc9" class="graf graf--li graf-after--p">Yes, the number at index <code class="markup--code markup--li-code">i — 2</code> was negated like in the example just showcased. In that case, negation of the number at <code class="markup--code markup--li-code">i — 2</code> would have a capacity reduction for number at <code class="markup--code markup--li-code">i — 1</code>. In the example <code class="markup--code markup--li-code">4 1 2 1</code> , negating the 1 at index 1(0 based indexing) would reduce the capacity of the number 2 (at index 2) by 1. We refer to remaining values of numbers as capacities here. We need to consider this reduced capacity when performing the check to see if a number can be negated or not.</li></ul><pre name="28d5" id="28d5" class="graf graf--pre graf-after--li">number[i] &lt; reducedCapacityOfNumberAt(i - 1)</pre><ul class="postList"><li name="a228" id="a228" class="graf graf--li graf-after--pre">In case the number at index <code class="markup--code markup--li-code">i — 2</code> wasn’t negated, the number at <code class="markup--code markup--li-code">i — 1</code> is at it’s full capacity. The simple check</li></ul><pre name="267b" id="267b" class="graf graf--pre graf-after--li">number[i] &lt; number[i - 1]</pre><p name="72ce" id="72ce" class="graf graf--p graf-after--pre">would be enough to see if we can negate the number at index <code class="markup--code markup--p-code">i</code> .</p><p name="54cc" id="54cc" class="graf graf--p graf-after--p">Let’s look at the code for the recursion containing all the ideas discussed above.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="2ef6" id="2ef6" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 810px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 81%;"></div><img class="graf-image" data-image-id="1*Ng2Sul4EQstOGK91DEfFHw.png" data-width="2424" data-height="1964" src="https://cdn-images-1.medium.com/max/1000/1*Ng2Sul4EQstOGK91DEfFHw.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="944e" id="944e" class="graf graf--p graf-after--figure">That’s all nice and dandy. But, this is just recursion, and the heading says dynamic programming. That means there would be overlapping subproblems. Let us look at the recursion tree to see if there are any.</p><figure name="6d09" id="6d09" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 602px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 85.9%;"></div><img class="graf-image" data-image-id="1*LI4UwrN7wA-ep0k-mUUtpQ.png" data-width="1436" data-height="1234" src="https://cdn-images-1.medium.com/max/800/1*LI4UwrN7wA-ep0k-mUUtpQ.png"></div></figure><p name="819a" id="819a" class="graf graf--p graf-after--figure">As you can see, there are overlapping subproblems in the recursion tree. That is why we can use memoization.</p><p name="3953" id="3953" class="graf graf--p graf-after--p">The memoization is as simple as:</p><pre name="dc55" id="dc55" class="graf graf--pre graf-after--p">&quot;&quot;&quot; This comes at the top. We check if the state represented by the tuple of the index and the boolean variable is already cached &quot;&quot;&quot;</pre><pre name="ef08" id="ef08" class="graf graf--pre graf-after--pre">if(memo[i][is_prev_negated] != INF) <br>{<br>    return memo[i][is_prev_negated];<br>}<br><br></pre><pre name="4df0" id="4df0" class="graf graf--pre graf-after--pre">...... CODE<br><br></pre><pre name="67be" id="67be" class="graf graf--pre graf-after--pre"># Cache the minimum sum from this index onwards.<br>memo[i][is_prev_negated] = min(pos, neg);</pre><pre name="6dc5" id="6dc5" class="graf graf--pre graf-after--pre"># The parent pointer is used for finding out the final set of #s<br>parent[i][is_prev_negated] = min(pos, neg) == pos ? 1 : -1;</pre><p name="9afc" id="9afc" class="graf graf--p graf-after--pre">As pointed out earlier, this recursive approach would return the minimum sum of the set of numbers possible after making the valid set of modifications to them.</p><p name="ef07" id="ef07" class="graf graf--p graf-after--p">The question, however, asks us to actually print the final set of numbers that gives the minimum sum after making such modifications. For that, we need to use a parent pointer that would tell us at every index and boolean variable <code class="markup--code markup--p-code">is_prev_negated </code>’s value as to what optimal action was taken.</p><pre name="08d7" id="08d7" class="graf graf--pre graf-after--p">parent[i][is_prev_negated] = min(pos, neg) == pos ? 1 : -1;</pre><p name="6be5" id="6be5" class="graf graf--p graf-after--pre">So we simply store 1 or -1 depending upon if negating the number at index i (if possible!) gave us the minimum sum or if choosing to ignore it gave the minimum sum.</p><h3 name="bc60" id="bc60" class="graf graf--h3 graf-after--p">Backtracking</h3><p name="7a88" id="7a88" class="graf graf--p graf-after--h3">Now comes the part where we backtrack to find the solution to our original problem. Note that the decision for the very first number is what propagates the recursion further. If the first number was negated, the second number would be positive and the third number’s decision can be found using <code class="markup--code markup--p-code">parent[2][true]</code>. Similarly, if the first number wasn’t negated, then we move onto the second number and it’s decision can be found using <code class="markup--code markup--p-code">parent[1][false]</code> and so on. Let’s look at the code.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="cc4a" id="cc4a" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 739px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 73.9%;"></div><img class="graf-image" data-image-id="1*mhMeHj4y986IB_-Xce5Q2A.png" data-width="2610" data-height="1930" src="https://cdn-images-1.medium.com/max/1000/1*mhMeHj4y986IB_-Xce5Q2A.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="a053" id="a053" class="graf graf--h3 graf-after--figure">A Better Approach</h3><p name="48fa" id="48fa" class="graf graf--p graf-after--h3">If you take a look at the space complexity of the solution suggested, you will see that it’s a 2 dimensional dynamic programming solution because the state of the recursion is represented by two variables i.e. the index <code class="markup--code markup--p-code">i </code>representing what number of the array we are considering and then the boolean variable <code class="markup--code markup--p-code">is_prev_negated</code> . So the space complexity and the time complexity would be O(n*2) which is essentially O(n).</p><p name="ff62" id="ff62" class="graf graf--p graf-after--p">However, there is a slightly better approach as well to solving this problem as suggested by <a href="https://medium.com/u/842b783318b8" data-href="https://medium.com/u/842b783318b8" data-anchor-type="2" data-user-id="842b783318b8" data-action-value="842b783318b8" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Divya Godayal</a>. This problem can even be solved by 1 dimensional dynamic programming based solution.</p><p name="4e04" id="4e04" class="graf graf--p graf-after--p">Essentially, the boolean variable <code class="markup--code markup--p-code">is_prev_negated</code> is helping us to decide if we can negate a given number at index <code class="markup--code markup--p-code">i</code> or not as far as the left hand side of the array is concerned i.e. <code class="markup--code markup--p-code">all the numbers from 0 .. i-1</code> because the right hand side is anyways safe as all the numbers on that side are positive (as the recursion hasn’t reached them yet). So for the right hand side we simply checked the number at <code class="markup--code markup--p-code">i+1</code> but for the left hand side of index <code class="markup--code markup--p-code">i</code> we had to make use of the boolean variable <code class="markup--code markup--p-code">is_prev_negated</code> .</p><p name="81c6" id="81c6" class="graf graf--p graf-after--p">It turns out, that we can simply skip this boolean variable altogether and simply look ahead to decide if a number can be negated or not. Which simply means if you are at an index <code class="markup--code markup--p-code">i</code>, you check if that element along with the element at <code class="markup--code markup--p-code">i+2 </code>have the capacity to swallow the element at <code class="markup--code markup--p-code">i+1 </code>i.e.</p><pre name="405d" id="405d" class="graf graf--pre graf-after--p">numbers[i] + numbers[i+2] &gt;= numbers[i+1  (SWALLOW)</pre><p name="4c2c" id="4c2c" class="graf graf--p graf-after--pre">If there is a such a possibility, then we directly jump to <code class="markup--code markup--p-code">i+3</code>if we negate element at <code class="markup--code markup--p-code">i </code>because element at <code class="markup--code markup--p-code">i+1 </code>and <code class="markup--code markup--p-code">i+2 </code>both can’t be negative in such a scenario.</p><p name="c492" id="c492" class="graf graf--p graf-after--p">In case the swallow condition is not satisfied and we end up negating the number at index <code class="markup--code markup--p-code">i</code> , then we would jump to index <code class="markup--code markup--p-code">i+2</code> because in any case, two consecutive numbers cannot be negated. So if the number at <code class="markup--code markup--p-code">i</code> was negated, then the number at <code class="markup--code markup--p-code">i+1</code> has to be positive. The swallow check is to see if the number at <code class="markup--code markup--p-code">i+2</code> would definitely have to be positive or if we can exercise the choice of whether to negate or not there.</p><p name="f51e" id="f51e" class="graf graf--p graf-after--p">Have a look at the code for a better understanding.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="a0a8" id="a0a8" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 734px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 73.4%;"></div><img class="graf-image" data-image-id="1*d3XdH8Qi2dwLsRX5G9E3sQ.png" data-width="2296" data-height="1686" src="https://cdn-images-1.medium.com/max/1000/1*d3XdH8Qi2dwLsRX5G9E3sQ.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="13fd" id="13fd" class="graf graf--p graf-after--figure">Hence, just a single variable i.e. the index is used to define the state of the recursion. So the time and space complexity, both got reduced to half of what they were in the previous solution.</p><p name="e47c" id="e47c" class="graf graf--p graf-after--p graf--trailing">I hope you were able to grasp the working of the algorithm described above and how the dynamic programming technique fits into this problem. I think it’s an interesting problem, because you not only have to use dynamic programming but also the concept of parent pointer to retrace the steps through the optimal solution and get the answer required in the question.</p></div></div></section>
</section>
</article></body></html>
