---
layout: post
title: "Tree Traversals explained: They’re like a class of lazy students trying to cheat on their exam"
comments: True
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Tree Traversals explained: They’re like a class of lazy students trying to cheat on their exam</title><style>
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 100%;
        margin: auto;
      }
      section {
        width: 100%;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 100%;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Tree Traversals explained: They’re like a class of lazy students trying to cheat on their exam</h1>
</header>
<section data-field="subtitle" class="p-summary">
Imagine that you are enrolled in a math class at one of the most prestigious universities of the world.
</section>
<section data-field="body" class="e-content">
<section name="83ec" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5e0b" id="5e0b" class="graf graf--h3 graf--leading graf--title"></h3></div><div class="section-inner sectionLayout--fullWidth"><figure name="419e" id="419e" class="graf graf--figure graf--layoutFillWidth graf-after--h3"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.99999999999999%;"></div><img class="graf-image" data-image-id="1*tCYpJPPIECnHUWw9BR_vrg.png" data-width="1252" data-height="714" src="https://cdn-images-1.medium.com/max/2000/1*tCYpJPPIECnHUWw9BR_vrg.png"></div><figcaption class="imageCaption"><a href="http://blog.noplag.com/wp-content/uploads/2017/01/cheating-on-a-test-clip-art-red-cheating-on-blues-test.png" data-href="http://blog.noplag.com/wp-content/uploads/2017/01/cheating-on-a-test-clip-art-red-cheating-on-blues-test.png" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">http://blog.noplag.com/wp-content/uploads/2017/01/cheating-on-a-test-clip-art-red-cheating-on-blues-test.png</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="3d47" id="3d47" class="graf graf--p graf-after--figure">Imagine that you are enrolled in a math class at one of the most prestigious universities of the world.</p><p name="0f00" id="0f00" class="graf graf--p graf-after--p">You have an exam coming up real soon. Obviously, you want to perform well on the exam.</p><p name="2159" id="2159" class="graf graf--p graf-after--p">The thing about this university is that it has a clumsy set of professors. So cheating is really simple. You can easily copy from the guy sitting behind and ahead without getting caught.</p><p name="921b" id="921b" class="graf graf--p graf-after--p">The professors, in order to take control of this problem, came up with two solutions:</p><ul class="postList"><li name="3554" id="3554" class="graf graf--li graf-after--p">The number of students sitting in a class is never fixed. And the people sitting in one class taking the test change from one test to another.</li><li name="313f" id="313f" class="graf graf--li graf-after--li">The seating arrangement is released five minutes before the exam. The seating arrangement is alphabetical. But since the students are never fixed and new ones may get added or old ones removed from a class randomly, the arrangement has to be explicitly released for the students to know where exactly they have to sit.</li></ul><p name="77f7" id="77f7" class="graf graf--p graf-after--li">Say you’re one of those lazy students who wants to cheat, despite the consequences. Five minutes before the exam when the seating arrangement is released, how do you find out who is sitting in front of you and who’s behind as quickly as possible?</p><p name="c776" id="c776" class="graf graf--p graf-after--p">You won’t be able to cheat if you don’t talk to these two people beforehand and strategize, right?</p><h3 name="ed83" id="ed83" class="graf graf--h3 graf-after--p">The Seating Arrangement</h3><p name="458f" id="458f" class="graf graf--p graf-after--h3">So the professors released the seating arrangement for the first test ever conducted this way. Say it had N students. If these students were to remain the same from one test to another, then it would have been very easy to cheat, right? Because the seating arrangement is always done alphabetically.</p><p name="3d37" id="3d37" class="graf graf--p graf-after--p">Therefore, the professors keep on adding or removing students from this list from one test to another, and only released these modifications before each test. This way, students could never know deterministically before a test who would be sitting in front of or behind them.</p><p name="8d25" id="8d25" class="graf graf--p graf-after--p">Let’s consider this problem in algorithmic terms. We are given a list of N elements where elements in this case are student’s names. This list keeps on varying from one exam to another, such that new elements can be added to the list or existing elements can be removed from the list.</p><p name="0d17" id="0d17" class="graf graf--p graf-after--p">Given the list of modifications at any given time T and a name N, we need to determine the elements B and A, such that B would come right before N and A would come right after N if the list were to be sorted.</p><p name="173b" id="173b" class="graf graf--p graf-after--p">Now let’s look at what data structures are available to us and what would suit this problem the best.</p><h3 name="c56c" id="c56c" class="graf graf--h3 graf-after--p">Oh Array, my old friend, will you help me?</h3><p name="be20" id="be20" class="graf graf--p graf-after--h3">Using an array seems to be a rather straightforward approach.</p><ul class="postList"><li name="4486" id="4486" class="graf graf--li graf-after--p">We can simply put all the names on the released list in an array.</li><li name="1265" id="1265" class="graf graf--li graf-after--li">Then we sort all the names (the list of names released might be randomly arranged) lexicographically</li><li name="c626" id="c626" class="graf graf--li graf-after--li">And then we can find our name in the list by using a binary search procedure. This would give us the predecessor and the successor.</li></ul><p name="fab0" id="fab0" class="graf graf--p graf-after--li">This seems to be a viable approach to solve this problem. The issue at hand, however, is that the students are never fixed from one exam to another. And so the list that was released for the very first exam would vary dynamically when new students were added and old ones were removed.</p><p name="a57e" id="a57e" class="graf graf--p graf-after--p">We can sort the list for the very first time, and then keep on adding new elements and removing old ones accordingly moving forward.</p><p name="23fa" id="23fa" class="graf graf--p graf-after--p">However, the complexity of adding or removing an element from an array is of the order <code class="markup--code markup--p-code">O(n)</code> . Since the number of students could be very large, and we don’t know how many modifications there would be before some new test, this would take a lot of time and the test would start before we could solve the problem. Remember that the modifications are released just five minutes before the test.</p><p name="d1e6" id="d1e6" class="graf graf--p graf-after--p">So what other data structure do we have where insertion and deletion can be done very quickly?</p><h3 name="334b" id="334b" class="graf graf--h3 graf-after--p">Hmmmm, maybe Linked List is my true friend after all</h3><p name="77b0" id="77b0" class="graf graf--p graf-after--h3">As far as a linked list is concerned, it has it’s own set of problems when dealing with this type of situation. Initially, we need to sort the list of elements lexicographically. Since this is a one-time operation, because it is only to be done for the first exam, the time taken here does not really matter.</p><p name="310c" id="310c" class="graf graf--p graf-after--p">From the next exam onwards, only the modifications are released. Adding or deleting an element from a linked list is a constant time operation, provided we know the location of that element in the list.</p><p name="378e" id="378e" class="graf graf--p graf-after--p">Finding an element in a linked list is a linear time operation — it takes <code class="markup--code markup--p-code">O(n)</code> . I know there are concepts like <a href="https://en.wikipedia.org/wiki/Skip_list" data-href="https://en.wikipedia.org/wiki/Skip_list" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">skip lists</a>, but why dive into something like this when we can solve this problem in a much better fashion by using another type of data structure?</p><h3 name="12d4" id="12d4" class="graf graf--h3 graf-after--p">Enter Binary Search Trees, the new kid in town</h3><p name="a1f7" id="a1f7" class="graf graf--p graf-after--h3">Let’s look at how we can model our data using a binary search tree (BST). Then we’ll see how a BST can help us solve the problem we initially set out to solve.</p><p name="bc4e" id="bc4e" class="graf graf--p graf-after--p">A Binary Search Tree is basically a binary tree with a special way of ordering the nodes.</p><p name="0e66" id="0e66" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">For a node with key <em class="markup--em markup--p-em">k</em>, every key in the left subtree is less than <em class="markup--em markup--p-em">k </em>and every key in the right subtree is greater than <em class="markup--em markup--p-em">k</em>.</strong></p><p name="9e6b" id="9e6b" class="graf graf--p graf-after--p">In our case, the keys will be the names of the students.</p><p name="fc77" id="fc77" class="graf graf--p graf-after--p">Consider the following example to see how a binary search tree is constructed. This should lend greater clarity to the data structure.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="2272" id="2272" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 1167px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 116.7%;"></div><img class="graf-image" data-image-id="1*fvAa2lIvPcl3pEF0EwjT_g.png" data-width="1200" data-height="1400" src="https://cdn-images-1.medium.com/max/1000/1*fvAa2lIvPcl3pEF0EwjT_g.png"></div><figcaption class="imageCaption"><a href="http://btechsmartclass.com/DS/images/BST%20Construction.png" data-href="http://btechsmartclass.com/DS/images/BST%20Construction.png" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">http://btechsmartclass.com/DS/images/BST%20Construction.png</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="7c4f" id="7c4f" class="graf graf--p graf-after--figure">Constructing a Binary Search Tree is not enough. We need to make sure it is <a href="http://www.stoimen.com/blog/2012/07/03/computer-algorithms-balancing-a-binary-search-tree/" data-href="http://www.stoimen.com/blog/2012/07/03/computer-algorithms-balancing-a-binary-search-tree/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">balanced</a>. The reason we say that a Binary Search Tree needs to be balanced is that, if it is not balanced, then we can have something like this:</p><figure name="c4e4" id="c4e4" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 781px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 111.60000000000001%;"></div><img class="graf-image" data-image-id="1*4rHcryjV-ySjXORcxzqQeA.png" data-width="896" data-height="1000" src="https://cdn-images-1.medium.com/max/800/1*4rHcryjV-ySjXORcxzqQeA.png"></div><figcaption class="imageCaption">A left skewed binary search tree.</figcaption></figure><p name="5523" id="5523" class="graf graf--p graf-after--figure">This is known as a skewed binary search tree. If such a thing happens, then the BST basically transforms into a linked list and that is of no use to us. Therefore, we have this notion of keeping a BST balanced so that we don’t run into this problem.</p><p name="f2ea" id="f2ea" class="graf graf--p graf-after--p">The notion of balanced is defined differently by different approaches, like Red Black Trees or AVL trees. Further explanation of these trees is out of the scope of this article.</p><p name="8aba" id="8aba" class="graf graf--p graf-after--p">Coming back to arranging our data in a balanced BST: the keys to our BST would be the names of the students, and lexicographic matching would be used to determine the structure of the BST.</p><p name="edc4" id="edc4" class="graf graf--p graf-after--p">Suppose that there were a million students taking the test. If our binary search tree is balanced, then the complexity of performing any operation is upper bounded by <code class="markup--code markup--p-code">O(log(n))</code> . <strong class="markup--strong markup--p-strong">Hence, for 1 million nodes, the maximum number of nodes to be scanned would be just 14.</strong></p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="bcfe" id="bcfe" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 750px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="1*WX_no1yjkuvyro78viF21w.png" data-width="1920" data-height="1440" src="https://cdn-images-1.medium.com/max/1000/1*WX_no1yjkuvyro78viF21w.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="57ea" id="57ea" class="graf graf--p graf-after--figure">That’s a lot of complexity reduction simply by arranging the data in a certain manner. That is the advantage of representing data in a <strong class="markup--strong markup--p-strong">balanced<em class="markup--em markup--p-em"> </em></strong>Binary Search Tree.</p><p name="4acf" id="4acf" class="graf graf--p graf-after--p">The main problem with the array-based approach was that we could not efficiently insert or delete an element from the array. And the problem with the linked list approach was that there was no efficient way for us to find an element in the linked list even if it were sorted.</p><p name="53ff" id="53ff" class="graf graf--p graf-after--p">As for a balanced binary search tree, the time complexity to insert, delete, or search for an element is all bounded by <code class="markup--code markup--p-code">O(log(n))</code> . And this is precisely what makes this data structure extremely exciting.</p><p name="d72e" id="d72e" class="graf graf--p graf-after--p">However, we still haven’t solved our original problem. Given the name of a student, we want to find out the student sitting right behind and right in front of them. This boils down to finding the <strong class="markup--strong markup--p-strong">in-order successor and predecessor in the given Binary Search Tree.</strong></p><h3 name="f5a0" id="f5a0" class="graf graf--h3 graf-after--p">In-order Traversal and Sorted Order in a BST</h3><p name="cc30" id="cc30" class="graf graf--p graf-after--h3">An interesting property of the binary search trees is that we can retrieve the elements in the sorted order (even reverse) by doing an in-order traversal over the binary search tree.</p><p name="5169" id="5169" class="graf graf--p graf-after--p">So the in-order successor of a node X is the element that comes right after X in the in-order traversal over the given BST. For our cheating problem, this in-order successor would be the student sitting in front of us.</p><p name="ed62" id="ed62" class="graf graf--p graf-after--p">The in-order predecessor of a node X is the element that comes right before X in the in-order traversal (or the element that comes right after X in the <strong class="markup--strong markup--p-strong">reverse<em class="markup--em markup--p-em"> </em></strong>in-order traversal) over the given BST. For our cheating problem, this in-order predecessor would be the student sitting right behind us.</p><h3 name="6134" id="6134" class="graf graf--h3 graf-after--p">In-order Successor in a BST</h3><p name="33f2" id="33f2" class="graf graf--p graf-after--h3">There are two different cases that we need to handle when finding the in-order successor of a node in a BST.</p><p name="245d" id="245d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The first case</strong> is when the right child exists for the node whose in-order successor we are trying to find. Consider the following example.</p><figure name="6e30" id="6e30" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 657px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 93.8%;"></div><img class="graf-image" data-image-id="1*HT_4eHf-yWORRyajZGfbqg.png" data-width="1164" data-height="1092" src="https://cdn-images-1.medium.com/max/800/1*HT_4eHf-yWORRyajZGfbqg.png"></div></figure><p name="2b63" id="2b63" class="graf graf--p graf-after--figure">Here we wanted to find the in-order successor of the highlighted node 8. Since it has a right child, the <strong class="markup--strong markup--p-strong">in-order successor would be the leftmost node in the tree with a right child, or 15 as the root</strong>. So that node would be 10 in this case.</p><p name="d2ca" id="d2ca" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The second case</strong> is when there is no right child.</p><figure name="8cae" id="8cae" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 491px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 70.1%;"></div><img class="graf-image" data-image-id="1*z6Q879IxNa5B6jRC6s1CaQ.png" data-width="1024" data-height="718" src="https://cdn-images-1.medium.com/max/800/1*z6Q879IxNa5B6jRC6s1CaQ.png"></div></figure><p name="5c99" id="5c99" class="graf graf--p graf-after--figure">In this case, the in-order successor has two possibilities:</p><ol class="postList"><li name="0bac" id="0bac" class="graf graf--li graf-after--p">One is where the node under consideration is the left child of its parent. In this case, the in-order successor would be the parent itself. So for our given case, the in-order successor would be 10.</li><li name="d6a3" id="d6a3" class="graf graf--li graf-after--li">The second case is when the current node is the right child of it’s parent. And it doesn’t have a right child. So it is the rightmost node in the BST and it has no in-order successor.</li></ol><p name="45f3" id="45f3" class="graf graf--p graf-after--li">Handling the first case is fairly simple for a binary search tree. For the second case, where the given node does not have a right child (or any parent pointers), we will have to rely on our good ol’ recursion mechanism and do an in-order traversal until we figure out the parent of our given node.</p><figure name="b0af" id="b0af" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/3027aa03ef813ae30d318d1b5e4de6bc.js"></script></figure><p name="e5e6" id="e5e6" class="graf graf--p graf-after--figure">So, the worst case complexity can be O(n) if the case above occurs.</p><p name="9030" id="9030" class="graf graf--p graf-after--p">Using this algorithm, we can quickly find out the student who will be sitting right in front of us in the exam.</p><h3 name="f498" id="f498" class="graf graf--h3 graf-after--p">In-order Predecessor in a BST</h3><p name="a6fe" id="a6fe" class="graf graf--p graf-after--h3">This is the exact reverse of the previous case.</p><p name="1298" id="1298" class="graf graf--p graf-after--p">Again, we need to handle two different cases when finding the in-order predecessor of a node in a BST. Look at the following diagrams and try to relate the two cases being referred to here.</p><figure name="cfc2" id="cfc2" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 585px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 83.6%;"></div><img class="graf-image" data-image-id="1*8LEzigzWixE_psr5BDeqdA.png" data-width="1100" data-height="920" src="https://cdn-images-1.medium.com/max/800/1*8LEzigzWixE_psr5BDeqdA.png"></div></figure><p name="9a68" id="9a68" class="graf graf--p graf-after--figure">This is the case where the node has a left child. We need to find the rightmost child of the tree rooted at this left child — the rightmost node in the tree rooted at 2.</p><figure name="a3da" id="a3da" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 556px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 79.4%;"></div><img class="graf-image" data-image-id="1*MXJ1lCqihi0bmcfelm5WFA.png" data-width="1096" data-height="870" src="https://cdn-images-1.medium.com/max/800/1*MXJ1lCqihi0bmcfelm5WFA.png"></div></figure><p name="1e87" id="1e87" class="graf graf--p graf-after--figure">No left child. So we need to find the parent.</p><figure name="3c9b" id="3c9b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/ada4adda364c26e87ff658659eb082b2.js"></script></figure><p name="4ae6" id="4ae6" class="graf graf--p graf-after--figure">If you look closely, I’ve just reversed the order of traversal here and the rest of the code is the same as before. (NOTE: this code is used when there is no left child of the node for which we want to find the in-order predecessor).</p><p name="b363" id="b363" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">In-order predecessor becomes the reverse in-order successor.</strong></p><p name="b36d" id="b36d" class="graf graf--p graf-after--p">Well now that you know how you should arrange the class seating arrangement list, go get some solid marks 😜😜😜. Just kidding!! Cheating is bad — don’t ever do it!</p><p name="4fa9" id="4fa9" class="graf graf--p graf-after--p">Hope you got the main idea behind the different usages for data structures and how to find the in-order successor and predecessor in a BST.</p><p name="502e" id="502e" class="graf graf--p graf-after--p graf--trailing">EDIT: Kudos to <a href="https://medium.com/u/842b783318b8" data-href="https://medium.com/u/842b783318b8" data-anchor-type="2" data-user-id="842b783318b8" data-action-value="842b783318b8" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Divya Godayal</a> for pointing out a set of major mistakes in the initial draft and also for ensuring that the article flows nicely :) :)</p></div></div></section>
</section>
</article></body></html>
