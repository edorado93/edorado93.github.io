---
layout: post
title: "Fun with array rotations"
comments: True
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Fun with array rotations</title><style>
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 100%;
        margin: auto;
      }
      section {
        width: 100%;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 100%;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Fun with array rotations</h1>
</header>
<section data-field="subtitle" class="p-summary">
Arrays are one of the most versatile data structures out there. Arrays form the basis of so many applications and numerous algorithms and‚Ä¶
</section>
<section data-field="body" class="e-content">
<section name="ff6f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="59fb" id="59fb" class="graf graf--h3 graf--leading graf--title"></h3></div><div class="section-inner sectionLayout--outsetColumn"><figure name="524c" id="524c" class="graf graf--figure graf--iframe graf--layoutOutsetCenter graf-after--h3"><iframe src="https://giphy.com/embed/xT0xez0JE0BFpQsx68/twitter/iframe" width="100%" height="600" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">Source: <a href="https://giphy.com/" data-href="https://giphy.com/" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://giphy.com/</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="8eaa" id="8eaa" class="graf graf--p graf-after--figure">Arrays are one of the most versatile data structures out there. Arrays form the basis of so many applications and numerous algorithms and data structures are based on them.</p><p name="cac8" id="cac8" class="graf graf--p graf-after--p">For e.g. the <a href="https://www.geeksforgeeks.org/binary-search/" data-href="https://www.geeksforgeeks.org/binary-search/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">binary search</a> algorithm works the way it does because the array data structure provides us with <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">random access </em></strong>of the contents. If we take away the random access, we can‚Äôt execute the famous binary search algorithm with the same time complexities as before.</p><p name="432a" id="432a" class="graf graf--p graf-after--p">Similarly, we have the <a href="https://www.geeksforgeeks.org/priority-queue-set-1-introduction/" data-href="https://www.geeksforgeeks.org/priority-queue-set-1-introduction/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">priority queue</a> data structure which is again based on the array representation of a complete binary tree and the heap in itself is a root of a so many applications out there.</p><p name="72ee" id="72ee" class="graf graf--p graf-after--p">This particular article will deal with programming problems related to <strong class="markup--strong markup--p-strong">rotation in arrays and strings. </strong>This is a fairly interesting domain of problems and we will look at a bunch of different problems based on the concept of rotation in the arrays.</p><p name="55af" id="55af" class="graf graf--p graf-after--p">Before starting off with the actual problems, let us first look at some examples of rotations and try and answer the following questions about rotations:</p><ol class="postList"><li name="47e4" id="47e4" class="graf graf--li graf-after--p">What is a rotation¬†?</li><li name="5797" id="5797" class="graf graf--li graf-after--li">How many rotations are possible for an array containing N elements¬†?</li><li name="570c" id="570c" class="graf graf--li graf-after--li">What is the time complexity of rotating an array by one element¬†?</li><li name="4bef" id="4bef" class="graf graf--li graf-after--li">Some Python magic to implement rotations.</li></ol><h4 name="141a" id="141a" class="graf graf--h4 graf-after--li">What is a rotation?</h4><p name="c163" id="c163" class="graf graf--p graf-after--h4">The diagram below will make it fairly clear as to what rotation is actually.</p><figure name="de08" id="de08" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 577px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 82.5%;"></div><img class="graf-image" data-image-id="1*SMBbUixxasHdYGs83nKYJQ.png" data-width="1450" data-height="1196" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*SMBbUixxasHdYGs83nKYJQ.png"></div></figure><p name="5639" id="5639" class="graf graf--p graf-after--figure">Essentially, we remove the first element of the array and we place it in the end and we shift all of the remaining elements one step to the left. This is an example of <strong class="markup--strong markup--p-strong">left rotation.</strong></p><p name="ca99" id="ca99" class="graf graf--p graf-after--p">Similarly we can have <strong class="markup--strong markup--p-strong">right rotation.</strong></p><figure name="e967" id="e967" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 611px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 87.3%;"></div><img class="graf-image" data-image-id="1*U19AaoiY4uRsIaS7kMVU0g.png" data-width="1418" data-height="1238" src="https://cdn-images-1.medium.com/max/800/1*U19AaoiY4uRsIaS7kMVU0g.png"></div></figure><h4 name="2b3e" id="2b3e" class="graf graf--h4 graf-after--figure"><strong class="markup--strong markup--h4-strong">Number of Rotations?</strong></h4><p name="d7ee" id="d7ee" class="graf graf--p graf-after--h4">The diagrams above make it pretty clear. Whether we have left rotation or right rotation, for an array of N elements, we will have N possible rotated arrays (including self).</p><h4 name="d06f" id="d06f" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Time Complexity of Rotation?</strong></h4><p name="7df1" id="7df1" class="graf graf--p graf-after--h4">Essentially what we do when we rotate an array is we remove the first element (considering we are talking about left rotation) and we shift <strong class="markup--strong markup--p-strong">all of the remaining elements </strong>one place to the left and finally we insert the element we removed from the first location at the very end of the array.</p><p name="dafb" id="dafb" class="graf graf--p graf-after--p">Since every time we have to do a rotation step, be it left or right rotation, the remaining N-1 elements have to be <strong class="markup--strong markup--p-strong">shifted</strong> as well to accommodate the rotation, the time complexity of this operation is <strong class="markup--strong markup--p-strong">O(N).</strong></p><h4 name="0eab" id="0eab" class="graf graf--h4 graf-after--p">Python Magic!¬†üßô‚Äç</h4><p name="ebe1" id="ebe1" class="graf graf--p graf-after--h4">There are many ways we can go about this. We will only showcase methods for doing left rotation and the right rotation can be achieved in similar ways. So that is left as an exercise for the reader.</p><figure name="0efa" id="0efa" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/86843f5fcab64edb03c568b1dc16d92f.js"></script></figure><p name="25ee" id="25ee" class="graf graf--p graf-after--figure">This is the most basic way of implementing one step of left rotation on a given array. We simply place the first element in the very end and before we do that we shift each of the remaining elements i.e. starting index 1 (for a 0 based indexing of the array), one step to the left.</p><p name="b3d8" id="b3d8" class="graf graf--p graf-after--p">This approach actually ends up modifying the underlying array. A lot of times we are only interested in the rotated version of the array or we are interested in all of the rotations of the given array, however, <em class="markup--em markup--p-em">we don‚Äôt really want to modify the underlying array</em>. You can say that the given array is a read only data structure.</p><p name="1e89" id="1e89" class="graf graf--p graf-after--p">If you notice carefully, in order to do left rotation for the Nth time, you would need the result of the previous rotation. So, for e.g. if the original array given to us was <code class="markup--code markup--p-code">[1,2,3,4,5]</code> and you follow the method listed above, after one rotation this would become <code class="markup--code markup--p-code">[2,3,4,5,1]</code> and then we can perform one more left rotation on this and get <code class="markup--code markup--p-code">[3,4,5,1,2]</code>¬†.</p><p name="70e4" id="70e4" class="graf graf--p graf-after--p">By following the above method, it‚Äôs really difficult to obtain the array that remains after N left rotations.</p><p name="5837" id="5837" class="graf graf--p graf-after--p">Let‚Äôs look at an interesting way using which we can achieve this.</p><figure name="1ebf" id="1ebf" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/999c7f812a456965de438df23d201769.js"></script></figure><p name="ca06" id="ca06" class="graf graf--p graf-after--figure">The trick here is the <strong class="markup--strong markup--p-strong">modulo</strong> operation. If you notice the rotated arrays, its like the starting point for the rotated array is actually some index <code class="markup--code markup--p-code">i</code> in the original array. This index <code class="markup--code markup--p-code">i</code> can be determined by the number <code class="markup--code markup--p-code">N</code> which represents the number of rotations we want to perform on the given array and then return the result.</p><p name="40b5" id="40b5" class="graf graf--p graf-after--p">Also, as you can imagine, N can be large as well. It can be larger than the length of the original array. However, after a certain point of time, the rotated array start to <strong class="markup--strong markup--p-strong">repeat itself</strong>. So, for an array of size N, after N-1 rotations, the next rotated array we get is the original one.</p><p name="fc39" id="fc39" class="graf graf--p graf-after--p">To understand why the modulo operation here works, have a look at the diagram below which shows a few rotations.</p><figure name="bd24" id="bd24" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 381px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 54.50000000000001%;"></div><img class="graf-image" data-image-id="1*zpLMk1Qml-vf-Obf82C6pQ.png" data-width="1916" data-height="1044" src="https://cdn-images-1.medium.com/max/800/1*zpLMk1Qml-vf-Obf82C6pQ.png"></div></figure><p name="58ca" id="58ca" class="graf graf--p graf-after--figure">Hope this diagram gives you enough clarity as to why we can simply do the modulo operation and we can directly get the array after N rotations have been performed on it.</p><p name="69f4" id="69f4" class="graf graf--p graf-after--p">Instead of writing the code like it has been shown in the code snippet earlier, we can also have a one liner for this in Python.</p><figure name="7710" id="7710" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/b4ad60251d88c10292733c18a0f7f833.js"></script></figure><p name="d911" id="d911" class="graf graf--p graf-after--figure">Now that we have a sense of rotations and we know how to play around with our array, we can finally look at some interesting problems centered around the concept of rotating an array.</p><h3 name="e73a" id="e73a" class="graf graf--h3 graf-after--p">Rotate Strings</h3><div name="2258" id="2258" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://leetcode.com/problems/rotate-string/description/" data-href="https://leetcode.com/problems/rotate-string/description/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://leetcode.com/problems/rotate-string/description/"><strong class="markup--strong markup--mixtapeEmbed-strong">Rotate String - LeetCode</strong><br><em class="markup--em markup--mixtapeEmbed-em">We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the‚Ä¶</em>leetcode.com</a><a href="https://leetcode.com/problems/rotate-string/description/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="2619bdcc37a935953fdf203b9069c3fd" data-thumbnail-img-id="0*OGwqlGnAuRSON_fJ" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*OGwqlGnAuRSON_fJ);"></a></div><p name="33db" id="33db" class="graf graf--p graf-after--mixtapeEmbed">Let‚Äôs see what this question asks us to do.</p><p name="4b2b" id="4b2b" class="graf graf--p graf-after--p">It says that we are given two strings A and B, which may or may not be of equal lengths üòõ (did you miss this¬†?), and we are to return true if any specific rotation of the string A can give us the string B.</p><p name="3c07" id="3c07" class="graf graf--p graf-after--p">In the diagram below we consider two strings <code class="markup--code markup--p-code">A = abcde</code> and <code class="markup--code markup--p-code">B = cdeab</code> and after two rotations the string A becomes equal to the string B. So in this case we return <code class="markup--code markup--p-code">True</code></p><figure name="0992" id="0992" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 400px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 57.199999999999996%;"></div><img class="graf-image" data-image-id="1*0EiMGafZknDavI5a6rbF3w.png" data-width="1794" data-height="1026" src="https://cdn-images-1.medium.com/max/800/1*0EiMGafZknDavI5a6rbF3w.png"></div></figure><p name="7384" id="7384" class="graf graf--p graf-after--figure">A simple check that will definitely return <code class="markup--code markup--p-code">False</code> is if the lengths of the two strings are different. In this case no matter what rotations we do, the strings can never be equal.</p><p name="37cd" id="37cd" class="graf graf--p graf-after--p">A very naive way of solving this problem is to find out all the rotations and then do string matching with the string B to see if the two strings become equal. We‚Äôll look at the solution first, then we‚Äôll see it‚Äôs complexity analysis and finally we will look at how well it fares among other solutions on the <a href="https://leetcode.com/" data-href="https://leetcode.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">leetcode</a> platform.</p><figure name="d9a7" id="d9a7" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/c9ba2f37d3f3612ccb7ab95b11240927.js"></script></figure><p name="0b0c" id="0b0c" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Time Complexity: </strong>O(N¬≤) because for every rotation we do a string matching of two strings of length N which takes O(N) and we have O(N) rotations in all.</p><p name="d7ef" id="d7ef" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Space Complexity:</strong> O(N) because we create a new list per rotation.</p><p name="21d0" id="21d0" class="graf graf--p graf-after--p">On the leetcode platform this solution performs poorly as expected.</p><figure name="1f2b" id="1f2b" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 284px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40.6%;"></div><img class="graf-image" data-image-id="1*b4wBFMsKYOqCfNN8A756DQ.png" data-width="3018" data-height="1226" src="https://cdn-images-1.medium.com/max/800/1*b4wBFMsKYOqCfNN8A756DQ.png"></div></figure><p name="5a50" id="5a50" class="graf graf--p graf-after--figure">It turns out that we can do better than this.</p><blockquote name="6ccd" id="6ccd" class="graf graf--pullquote graf-after--p">The idea here is to append the string A to itself and then check if the string B is a substring of this extended string A +¬†A</blockquote><p name="c31d" id="c31d" class="graf graf--p graf-after--pullquote">Why do we do this you might ask?</p><p name="f2f9" id="f2f9" class="graf graf--p graf-after--p">Well, it turns out that if we append a given array / string to itself, the resultant array or string covers all of the rotations of the original array. Let‚Äôs have a look at the diagram below to understand how this concatenation operation effectively yields all possible rotations. The string we will consider for this diagram below is <code class="markup--code markup--p-code">abcde</code> and so after concatenating this string with itself we get <code class="markup--code markup--p-code">abcdeabcde</code></p><figure name="823e" id="823e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 444px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 63.4%;"></div><img class="graf-image" data-image-id="1*ujBQcOnZKYLEQo2GsW-cbA.png" data-width="1612" data-height="1022" src="https://cdn-images-1.medium.com/max/800/1*ujBQcOnZKYLEQo2GsW-cbA.png"></div><figcaption class="imageCaption">Figure showing all possible rotations for string ‚Äúabcde‚Äù covered by ‚Äúabcdeabcde‚Äù</figcaption></figure><p name="2b10" id="2b10" class="graf graf--p graf-after--figure">Now if the string A or any rotation of A does in fact equal the string B, then the string B would be a substring of this enlarged string 2A.</p><p name="1ff8" id="1ff8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Time Complexity: </strong>O(N) because all we are doing is string matching between a string of size N and another one which is 2N.</p><p name="c291" id="c291" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Space Complexity: </strong>O(N) because we have to create a new string of size 2N to accommodate this enlarged version of the string A.</p><p name="6f84" id="6f84" class="graf graf--p graf-after--p">This algorithm is much faster than the previous one and much shorter to implement as well. It‚Äôs a one liner in Python üôà.</p><figure name="17cc" id="17cc" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/89dfb65f8bddee1373a4a149a2f57288.js"></script></figure><figure name="4cd1" id="4cd1" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 277px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 39.6%;"></div><img class="graf-image" data-image-id="1*kz0XpsWd5aVuRO8PeGJwXA.png" data-width="3040" data-height="1204" src="https://cdn-images-1.medium.com/max/800/1*kz0XpsWd5aVuRO8PeGJwXA.png"></div></figure><p name="e315" id="e315" class="graf graf--p graf-after--figure">I‚Äôd say that‚Äôs fast enough!</p><p name="8b9b" id="8b9b" class="graf graf--p graf-after--p">Let‚Äôs move on to another interesting problem that seems simple enough but has a bunch of caveats to consider before we get the perfect solution.</p><h3 name="f7af" id="f7af" class="graf graf--h3 graf-after--p">Minimum in Rotated Sorted¬†Array</h3><div name="0325" id="0325" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" data-href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/"><strong class="markup--strong markup--mixtapeEmbed-strong">Find Minimum in Rotated Sorted Array - LeetCode</strong><br><em class="markup--em markup--mixtapeEmbed-em">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7]‚Ä¶</em>leetcode.com</a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="76a2ee5e486ac16449ce3547abd6cb39" data-thumbnail-img-id="0*XyFUZLvROyYEDq82" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*XyFUZLvROyYEDq82);"></a></div><p name="8500" id="8500" class="graf graf--p graf-after--mixtapeEmbed">Before moving on, I would like to thank <a href="https://medium.com/u/842b783318b8" data-href="https://medium.com/u/842b783318b8" data-anchor-type="2" data-user-id="842b783318b8" data-action-value="842b783318b8" data-action="show-user-card" data-action-type="hover" class="markup--user markup--p-user" target="_blank">Divya Godayal</a> for contributing this section of the article. Cheers!</p><p name="7053" id="7053" class="graf graf--p graf-after--p">So the question simply asks us to find an element in an array that is</p><ul class="postList"><li name="25da" id="25da" class="graf graf--li graf-after--p">sorted,</li><li name="86cc" id="86cc" class="graf graf--li graf-after--li">rotated and apparently</li><li name="fc74" id="fc74" class="graf graf--li graf-after--li">doesn‚Äôt contain any duplicate elements.</li></ul><p name="6ebc" id="6ebc" class="graf graf--p graf-after--li">A very brute way of solving this question is to search the entire array and find the minimum element. This approach would simply ignore the fact that the given array is sorted and this is the naive approach to solve this problem. So first let us look at a simple linear search based solution for this problem.</p><figure name="2237" id="2237" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/274079fcb8739be1908df05f14110ab4.js"></script></figure><p name="7577" id="7577" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Time Complexity: </strong>O(N) if there are N elements in the given array.</p><p name="64f5" id="64f5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Space Complexity: </strong>O(1)</p><figure name="53d9" id="53d9" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 287px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 41%;"></div><img class="graf-image" data-image-id="1*qgqvdw3YGUZ1EkpEPgN91w.png" data-width="2952" data-height="1210" src="https://cdn-images-1.medium.com/max/800/1*qgqvdw3YGUZ1EkpEPgN91w.png"></div></figure><p name="0b0e" id="0b0e" class="graf graf--p graf-after--figure">This is actually interesting. An O(N) solution gives us the best execution time on leetcode. However, it turns out that we can do way better than this as far as the asymptotic complexity is concerned.</p><p name="0dd2" id="0dd2" class="graf graf--p graf-after--p">The face that the given array is <strong class="markup--strong markup--p-strong">sorted</strong> is a huge hint in itself. Since the array is sorted and we are to <strong class="markup--strong markup--p-strong">find </strong>an element in the array, we can use the <strong class="markup--strong markup--p-strong">binary search paradigm.</strong></p><p name="0c7d" id="0c7d" class="graf graf--p graf-after--p">However, the array is rotated. So simply applying the binary search won‚Äôt work here.</p><p name="eead" id="eead" class="graf graf--p graf-after--p">In this question we would essentially apply a modified version of binary search where the <code class="markup--code markup--p-code">condition</code> that decides the search direction would be different than in a standard binary search.</p><p name="bc6e" id="bc6e" class="graf graf--p graf-after--p">In a standard binary search algorithm we do the following</p><pre name="33aa" id="33aa" class="graf graf--pre graf-after--p">1. while left &lt;= right<br>2.     mid = (left + right) / 2<br>3.     if element == middle element:<br>4.         return mid <br>5.     elif element &lt; middle element:<br>6.         move to the left i.e. [left, mid - 1]<br>7.     else:<br>8.         move to the right i.e. [mid + 1, right].</pre><p name="60ff" id="60ff" class="graf graf--p graf-after--pre">Since the given array is sorted, we can definitely apply the binary search algorithm to search for the element. The only thing is, that the elements have been rotated and that is something we have to account for.</p><p name="e7fb" id="e7fb" class="graf graf--p graf-after--p">How do we check if the array is even rotated or not in the first place?</p><p name="1e6e" id="1e6e" class="graf graf--p graf-after--p">If the array is not rotated and the array is sorted in ascending order, then</p><pre name="697b" id="697b" class="graf graf--pre graf-after--p">last_element &gt; first_element</pre><figure name="c111" id="c111" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 318px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 45.4%;"></div><img class="graf-image" data-image-id="1*9xsYIqBE6sYlqihsVXa1Sg.png" data-width="1030" data-height="468" src="https://cdn-images-1.medium.com/max/800/1*9xsYIqBE6sYlqihsVXa1Sg.png"></div></figure><p name="5737" id="5737" class="graf graf--p graf-after--figure">In the above example <code class="markup--code markup--p-code">7 &gt; 2</code>. This means that the array does not have any rotation. In this case we can simply return the first element of the array as that would be the minimum element.</p><p name="f4b0" id="f4b0" class="graf graf--p graf-after--p">However, if the array is in fact rotated, then there would be a heartbeat formation happening somewhere in the array. Let‚Äôs look at what we mean by a heartbeat formation.</p><figure name="2ea3" id="2ea3" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 344px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 49.1%;"></div><img class="graf-image" data-image-id="1*2S9mmV3_RgHuzxBt2y32TA.png" data-width="1006" data-height="494" src="https://cdn-images-1.medium.com/max/800/1*2S9mmV3_RgHuzxBt2y32TA.png"></div></figure><p name="4950" id="4950" class="graf graf--p graf-after--figure">If you look at the elements of the array above, they are in increasing order as expected (because the array is sorted in ascending order). However, after the element 7, there‚Äôs a sudden drop and then the values start to increase again. This is the heartbeat structure we are talking about.</p><figure name="0c38" id="0c38" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 523px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 74.7%;"></div><img class="graf-image" data-image-id="1*a7QzJRtkag0vIo_wDyDzhg.png" data-width="1606" data-height="1200" src="https://cdn-images-1.medium.com/max/800/1*a7QzJRtkag0vIo_wDyDzhg.png"></div></figure><p name="c5be" id="c5be" class="graf graf--p graf-after--figure">In the array given above <code class="markup--code markup--p-code">3 &lt; 4</code>. Hence the array is rotated. This happens because the array was initially <code class="markup--code markup--p-code">[2, 3¬†,4¬†,5¬†,6¬†,7]</code>. But after the rotation the smaller elements<code class="markup--code markup--p-code">[2,3]</code> go at the back. i.e. [4, 5, 6, 7, <code class="markup--code markup--p-code">2, 3]</code>. Because of this the first element <code class="markup--code markup--p-code">[4]</code> in the rotated array becomes greater than the last element.</p><p name="0c4f" id="0c4f" class="graf graf--p graf-after--p">The heartbeat structure that is evident from the question means there is a point in the array at which you would notice a change. This is the point which would help us in this question. We call this the <code class="markup--code markup--p-code">Inflection Point</code>.</p><figure name="8301" id="8301" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 411px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 58.699999999999996%;"></div><img class="graf-image" data-image-id="1*hsud-p_WPaLZM2uO1ft9gA.png" data-width="886" data-height="520" src="https://cdn-images-1.medium.com/max/800/1*hsud-p_WPaLZM2uO1ft9gA.png"></div></figure><p name="c55a" id="c55a" class="graf graf--p graf-after--figure">An important property of the inflection point that would be critical in solving this question is:</p><blockquote name="d6d0" id="d6d0" class="graf graf--pullquote graf-after--p">* All the elements to the left of inflection point &gt; first element of the array.<br>* All the elements to the right of inflection point &lt; first element of the¬†array.</blockquote><p name="cd4d" id="cd4d" class="graf graf--p graf-after--pullquote">Let us now look at the algorithm to solve this question before looking at the implementation.</p><ol class="postList"><li name="26a1" id="26a1" class="graf graf--li graf-after--p">Find the <code class="markup--code markup--li-code">mid</code> element of the array.</li><li name="d719" id="d719" class="graf graf--li graf-after--li">If <code class="markup--code markup--li-code">mid element &gt; first element of array</code> this means that we need to look for the inflection point on the right of <code class="markup--code markup--li-code">mid</code>.</li><li name="85e2" id="85e2" class="graf graf--li graf-after--li">If <code class="markup--code markup--li-code">mid element &lt; first element of array</code> this that we need to look for the inflection point on the left of <code class="markup--code markup--li-code">mid</code>.</li></ol><figure name="d2fc" id="d2fc" class="graf graf--figure graf-after--li"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 328px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 46.9%;"></div><img class="graf-image" data-image-id="1*WQRllHEA0BpCYu3-eTUX6Q.png" data-width="938" data-height="440" src="https://cdn-images-1.medium.com/max/800/1*WQRllHEA0BpCYu3-eTUX6Q.png"></div></figure><p name="ad5a" id="ad5a" class="graf graf--p graf-after--figure">We stop our search when we find the inflection point, when either of the two conditions is satisfied:</p><p name="d613" id="d613" class="graf graf--p graf-after--p">‚Üí <code class="markup--code markup--p-code">nums[mid] &gt; nums[mid + 1]</code> Hence, <code class="markup--code markup--p-code">mid+1</code> is the smallest.</p><p name="93c1" id="93c1" class="graf graf--p graf-after--p">‚Üí <code class="markup--code markup--p-code">nums[mid - 1] &gt; nums[mid]</code> Hence, <code class="markup--code markup--p-code">mid</code> is the smallest.</p><figure name="07c6" id="07c6" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 323px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 46.2%;"></div><img class="graf-image" data-image-id="1*ob6oxgnNw0rwMcV7stlOUQ.png" data-width="818" data-height="378" src="https://cdn-images-1.medium.com/max/800/1*ob6oxgnNw0rwMcV7stlOUQ.png"></div></figure><figure name="10da" id="10da" class="graf graf--figure graf--iframe graf-after--figure"><script src="https://gist.github.com/edorado93/4912438b127ef4f46140c419e62c4304.js"></script></figure><p name="2a2f" id="2a2f" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Time Complexity: </strong>O(logN) because all we are doing here is relying on our good friend, binary search and thus making use of the sorted nature of the original array.</p><p name="1d2a" id="1d2a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Space Complexity: </strong>O(1)</p><figure name="cd23" id="cd23" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 288px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 41.199999999999996%;"></div><img class="graf-image" data-image-id="1*yNVQknQsg8xxj1EhaI5Jxg.png" data-width="2978" data-height="1226" src="https://cdn-images-1.medium.com/max/800/1*yNVQknQsg8xxj1EhaI5Jxg.png"></div></figure><p name="de00" id="de00" class="graf graf--p graf-after--figure">Can‚Äôt do better than that now, can we¬†? üòâ</p><p name="c9d8" id="c9d8" class="graf graf--p graf-after--p">The big catch in this problem is that <strong class="markup--strong markup--p-strong">there are no duplicate elements in the array. </strong>What if there are duplicate elements in the array¬†? Can we still follow a similar approach to solve the problem?</p><p name="3d22" id="3d22" class="graf graf--p graf-after--p">The answer to this question is yes and no. The same concepts that we discussed above apply to the this modified version of the problem as well. However, the time complexity is no longer guaranteed to be O(logN). Look at the following examples.</p><figure name="8ac7" id="8ac7" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 365px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 52.1%;"></div><img class="graf-image" data-image-id="1*moyfB_ciu0OzwfxBxhDlJA.png" data-width="1562" data-height="814" src="https://cdn-images-1.medium.com/max/800/1*moyfB_ciu0OzwfxBxhDlJA.png"></div></figure><p name="5102" id="5102" class="graf graf--p graf-after--figure">The two cases mentioned below are easier to solve because the middle element is different from the first and the last elements and can help direct the binary search (although you‚Äôd get stuck with a 4 as the mid point further down the binary search).</p><p name="6198" id="6198" class="graf graf--p graf-after--p">The point being is that since duplicate elements are allowed here, it is possible to have a scenario where:</p><pre name="ca8b" id="ca8b" class="graf graf--pre graf-after--p">leftmost element == middle element == rightmost element</pre><p name="4733" id="4733" class="graf graf--p graf-after--pre">and when this scenario takes place, how do we decide what direction we need to move towards. There is no possible way for us to know the direction that can be ignored by the binary search algorithm. So, we would have to try and consider both as possible candidates and process them and in case all of the elements are the same in our array i.e. <code class="markup--code markup--p-code">[4,4,4,4,4,4,4,4]</code> then we would eventually end up processing each of the elements one by one.</p><p name="46e5" id="46e5" class="graf graf--p graf-after--p">Therefore, with a heavy heart üò¢ we have to conclude that there is just no way to get a guaranteed O(logN) complexity algorithm on this question. The worst case time complexity of a modified version of the binary search algorithm we looked at above would be O(N).</p><figure name="de37" id="de37" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://giphy.com/embed/L95W4wv8nnb9K/twitter/iframe" width="100%" height="300" frameborder="0" scrolling="no"></iframe></figure><p name="38ec" id="38ec" class="graf graf--p graf-after--figure">Let us move on to the final question for this article and it is going to be a blockbuster one. Trust me!</p><h3 name="3f24" id="3f24" class="graf graf--h3 graf-after--p">Orderly Queue</h3><div name="4034" id="4034" class="graf graf--mixtapeEmbed graf-after--h3"><a href="https://leetcode.com/problems/orderly-queue/description/" data-href="https://leetcode.com/problems/orderly-queue/description/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://leetcode.com/problems/orderly-queue/description/"><strong class="markup--strong markup--mixtapeEmbed-strong">Orderly Queue - LeetCode</strong><br><em class="markup--em markup--mixtapeEmbed-em">A string S of lowercase letters is given. Then, we may make any number of moves. In each move, we choose one of the‚Ä¶</em>leetcode.com</a><a href="https://leetcode.com/problems/orderly-queue/description/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="cc6ed0c13fec40511228a5791c2e08dc" data-thumbnail-img-id="0*_tVOGsaH0F7bi7Bz" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*_tVOGsaH0F7bi7Bz);"></a></div><p name="6fc3" id="6fc3" class="graf graf--p graf-after--mixtapeEmbed">Let‚Äôs look at some of the possible string rotations first before getting to the solution. The string we will consider is <code class="markup--code markup--p-code">baaca</code> and K = 3 that means we can select <strong class="markup--strong markup--p-strong">any </strong>of the first three characters and then remove it from its location, add it to the very end and finally shift all the characters one position to the left to accommodate this new element in the end.</p><figure name="49f1" id="49f1" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 658px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 94%;"></div><img class="graf-image" data-image-id="1*7Inq12klLO2zUWK51atyEA.png" data-width="1270" data-height="1194" src="https://cdn-images-1.medium.com/max/800/1*7Inq12klLO2zUWK51atyEA.png"></div></figure><p name="5987" id="5987" class="graf graf--p graf-after--figure">Assume the string has the following characters: <code class="markup--code markup--p-code">a[0], a[1], a[2]¬†‚Ä¶ a[n-1]</code> and we want to swap some position i (i &gt;= 0 &amp;&amp; i &lt; n‚Ää‚Äî‚Ää1) with position i+1, or swap a[i] and a[i+1]. The claim is that we can achieve this for any two adjacent elements in the string by using rotations on the string. e.g.:- Say the string consists of 5 characters and we want to swap <code class="markup--code markup--p-code">a[2] and a[3]</code>¬†, here‚Äôs how we can achieve this with array rotations.</p><pre name="20ab" id="20ab" class="graf graf--pre graf-after--p">a[0], a[1], <strong class="markup--strong markup--pre-strong">a[2], a[3]</strong>, a[4], a[5]     ROTATE around first element</pre><pre name="3ec7" id="3ec7" class="graf graf--pre graf-after--pre">a[1], <strong class="markup--strong markup--pre-strong">a[2], a[3]</strong>, a[4], a[5], a[0]     ROTATE around first element</pre><pre name="38cf" id="38cf" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">a[2], a[3]</strong>, a[4], a[5], a[0], a[1]     ROTATE around <strong class="markup--strong markup--pre-strong">second </strong>element</pre><pre name="f047" id="f047" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">a[2], </strong>a[4], a[5], a[0], a[1], <strong class="markup--strong markup--pre-strong">a[3]</strong>     ROTATE around <strong class="markup--strong markup--pre-strong">first </strong>element</pre><pre name="89a4" id="89a4" class="graf graf--pre graf-after--pre">a[5], a[0], a[1], <strong class="markup--strong markup--pre-strong">a[3], a[2], </strong>a[4]     ROTATE around first<strong class="markup--strong markup--pre-strong"> </strong>element</pre><pre name="dbd9" id="dbd9" class="graf graf--pre graf-after--pre">a[0], a[1], <strong class="markup--strong markup--pre-strong">a[3], a[2], </strong>a[4], a[5]     ROTATE around first<strong class="markup--strong markup--pre-strong"> </strong>element</pre><p name="6974" id="6974" class="graf graf--p graf-after--pre">You can try playing around with this idea, but essentially we can swap any two adjacent elements in the given string by performing multiple rotations in the manner shown above.</p><blockquote name="474a" id="474a" class="graf graf--pullquote graf-after--p">Since we can swap any two elements, we can perform <strong class="markup--strong markup--pullquote-strong">Bubble¬†Sort!</strong></blockquote><p name="c395" id="c395" class="graf graf--p graf-after--pullquote">The bubble sort algorithm essentially involves comparison amongst adjacent elements for the purpose of <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">bubbling up/down elements to their respective positions in the array.</em></strong></p><p name="b456" id="b456" class="graf graf--p graf-after--p">Thus we have achieved swapping of chars a[2] and a[3] without disturbing ordering of other characters (similarly this can be done for any pair of adjacent indices).</p><p name="b74a" id="b74a" class="graf graf--p graf-after--p">Therefore, if K &gt; 1 in the question, we can essentially perform the bubble sort algorithm by using rotations and eventually the smallest lexicographic string that we would get would be the original string sorted in ascending order.</p><h4 name="f677" id="f677" class="graf graf--h4 graf-after--p">What about when K =¬†1?</h4><p name="d50c" id="d50c" class="graf graf--p graf-after--h4">In this case we don‚Äôt get that much freedom in ‚Äúchoosing‚Äù which element to move to the back of the array. In this case we have to look at all of the possible rotations of the original string and return the one that is lexicographically the smallest one.</p><p name="66e8" id="66e8" class="graf graf--p graf-after--p">If you remember correctly, the number of rotations for a string of size N are N. So, when K = 1, we would have to look at all of the array‚Äôs rotations (remember the <strong class="markup--strong markup--p-strong">mod</strong> method or <strong class="markup--strong markup--p-strong">concat</strong> methods we discussed in the article to get all rotations?) and obtain the smallest one lexicographically.</p><p name="ea59" id="ea59" class="graf graf--p graf-after--p">Let‚Äôs look at the implementation even though it is a very small one.</p><figure name="4185" id="4185" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/7f81dc1c7ede45e3bccec6ef3d436ba4.js"></script></figure><figure name="50af" id="50af" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 268px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 38.3%;"></div><img class="graf-image" data-image-id="1*sZ0ux-ic-q7EocVnVSGEag.png" data-width="3036" data-height="1162" src="https://cdn-images-1.medium.com/max/800/1*sZ0ux-ic-q7EocVnVSGEag.png"></div></figure><p name="cfe8" id="cfe8" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Time Complexity: </strong>O(NlogN) because we are sorting the string for K &gt; 1</p><p name="4ab4" id="4ab4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Space Complexity: </strong>O(N) because if K = 1, then we create S+S which is O(N) space allocation.</p><p name="bd62" id="bd62" class="graf graf--p graf-after--p">That‚Äôs it for this article. Hope you had a fun time learning rotations in arrays and I hope you were able to grasp all of the concepts that we discussed here.</p><blockquote name="93a0" id="93a0" class="graf graf--pullquote graf-after--p">All Hail¬†Coding‚Ä¶</blockquote><figure name="4f0f" id="4f0f" class="graf graf--figure graf--iframe graf-after--pullquote"><iframe src="https://giphy.com/embed/l0IyeVQX0wZ828cMg/twitter/iframe" width="100%" height="300" frameborder="0" scrolling="no"></iframe></figure><figure name="3aeb" id="3aeb" class="graf graf--figure graf-after--figure graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 350px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 50%;"></div><a href="https://goo.gl/w4Pbea" data-href="https://goo.gl/w4Pbea" class="graf-imageAnchor" data-action="image-link" data-action-observe-only="true"></a></div></figure></div></div></section>
</section>
<footer></footer></article></body></html>