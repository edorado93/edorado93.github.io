---
layout: post
title: "Recursion Demystified"
comments: True
---

<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Recursion Demystified</title>
    
    <style>
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 40px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 100%;
        margin: auto;
      }
      section {
        width: 100%;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 100%;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style>
    
    </head><body><article class="h-entry">
<section data-field="subtitle" class="p-summary">
In order to understand recursion, you must first understand recursion.
</section>
<section data-field="body" class="e-content">
<section name="e3cf" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3511" id="3511" class="graf graf--h3 graf--leading graf--title"></h3></div><div class="section-inner sectionLayout--fullWidth"><figure name="1b59" id="1b59" class="graf graf--figure graf--layoutFillWidth graf-after--h3"><div class="aspectRatioPlaceholder is-locked"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 36.4%;"></div><img class="graf-image" data-image-id="1*yNNmaPaMjbto_oSlcO7hvQ.png" data-width="2960" data-height="1076" src="https://cdn-images-1.medium.com/max/2000/1*yNNmaPaMjbto_oSlcO7hvQ.png"></div><figcaption class="imageCaption">Source: <a href="https://thomaspark.co/wp/wp-content/uploads/2017/01/xkcd.png" data-href="https://thomaspark.co/wp/wp-content/uploads/2017/01/xkcd.png" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://thomaspark.co/wp/wp-content/uploads/2017/01/xkcd.png</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><blockquote name="bc1c" id="bc1c" class="graf graf--pullquote graf-after--figure">In order to understand recursion, you must first understand recursion.</blockquote><p name="245f" id="245f" class="graf graf--p graf-after--pullquote">Crazy, isn’t it ?</p><p name="2f41" id="2f41" class="graf graf--p graf-after--p">Well, I hope that by the end of this article you will feel much more confident about what recursion is and mainly, how we can come up with a recursive solution to a problem.</p><h3 name="1488" id="1488" class="graf graf--h3 graf-after--p">What is Recursion?</h3><p name="7aa6" id="7aa6" class="graf graf--p graf-after--h3">How do you explain recursion to a 4 year old? This is a pretty famous interview question, and there are loads of answers available on the web. We won’t answer this question as it is too mainstream.</p><p name="4947" id="4947" class="graf graf--p graf-after--p">If you are as clever as I am 🤓🤓, you would explain recursion to someone one year younger than you. Have them explain recursion to someone one year younger than them. Continue until you have a 5 year old explaining recursion to a 4 year old. Done. [Source: <a href="https://www.reddit.com/r/programmerchat/comments/3ua9ie/how_would_you_explain_recursion_to_a_6_year_old/" data-href="https://www.reddit.com/r/programmerchat/comments/3ua9ie/how_would_you_explain_recursion_to_a_6_year_old/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">reddit</a>].</p><figure name="0bb3" id="0bb3" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://giphy.com/embed/gsYKROakiJQPu/twitter/iframe" width="100%" height="300" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption"><a href="https://giphy.com/gifs/reaction-gsYKROakiJQPu" data-href="https://giphy.com/gifs/reaction-gsYKROakiJQPu" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://giphy.com/gifs/reaction-gsYKROakiJQPu</a></figcaption></figure><p name="68d6" id="68d6" class="graf graf--p graf-after--figure">In programming terms, recursion is</p><blockquote name="f352" id="f352" class="graf graf--pullquote graf-after--p">A function calling itself.</blockquote><figure name="23fb" id="23fb" class="graf graf--figure graf--iframe graf-after--pullquote"><script src="https://gist.github.com/edorado93/e37127955dee6041a864337d1297a153.js"></script></figure><p name="6e6b" id="6e6b" class="graf graf--p graf-after--figure">The above function does no useful work as such, but it does demonstrate recursion. The recursive relation above would be</p><pre name="bb9c" id="bb9c" class="graf graf--pre graf-after--p">T(N) = T(N - 1) + O(1)</pre><p name="d18b" id="d18b" class="graf graf--p graf-after--pre">This simply means that the execution for the call to <code class="markup--code markup--p-code">random_function(n)</code> cannot proceed until the call to <code class="markup--code markup--p-code">random_function(n-1)</code> is completed and so on.</p><p name="1df0" id="1df0" class="graf graf--p graf-after--p">Essentially, we delay the execution of the current state of the function until another call to the same function has completed and returned it’s result.</p><p name="f6d5" id="f6d5" class="graf graf--p graf-after--p">The compiler keeps on saving the state of the function call now and then moves onto the next function call and so on. So, the compiler saves function states onto a stack and uses that for computations and backtracking.</p><figure name="38a6" id="38a6" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 707px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 101%;"></div><img class="graf-image" data-image-id="1*UkdvcDN_JPxLvB62pTTj2g.png" data-width="1420" data-height="1434" src="https://cdn-images-1.medium.com/max/800/1*UkdvcDN_JPxLvB62pTTj2g.png"></div><figcaption class="imageCaption">Recursion stack of a set of function calls.</figcaption></figure><p name="4433" id="4433" class="graf graf--p graf-after--figure">Essentially, if a problem can be broken down into similar subproblems which can be solved individually, and whose solutions can be combined together to get the overall solution, then we say that there might exist a recursive solution to the problem.</p><p name="d044" id="d044" class="graf graf--p graf-after--p">Instead of clinging to this seemingly old definition of recursion, we will look at a whole bunch of applications of recursion. Then hopefully things will be clear.</p><h3 name="0141" id="0141" class="graf graf--h3 graf-after--p">Factorial of a Number</h3><p name="d917" id="d917" class="graf graf--p graf-after--h3">Let us see how we can find out the factorial of a number. Before that, let’s see what the factorial of a number represents and how it is calculated.</p><pre name="de25" id="de25" class="graf graf--pre graf-after--p">factorial(N) = 1 * 2 * 3 * .... * N - 1 * N</pre><p name="a120" id="a120" class="graf graf--p graf-after--pre">Simply put, the factorial of a number is just the product of terms from 1 to the number N multiplied by one another.</p><p name="5147" id="5147" class="graf graf--p graf-after--p">We can simply have a <code class="markup--code markup--p-code">for</code> loop from 1 to N and multiply all the terms iteratively and we will have the factorial of the given number.</p><p name="0046" id="0046" class="graf graf--p graf-after--p">But, if you look closely, there exists an inherent recursive structure to the factorial of a number.</p><pre name="cfe6" id="cfe6" class="graf graf--pre graf-after--p">factorial(N) = N * factorial(N - 1)</pre><p name="6035" id="6035" class="graf graf--p graf-after--pre">It’s like offloading the computation to another function call operating on a smaller version of the original problem. Let’s see how this relation would unfold to verify if the solution here matches the one provided by the <code class="markup--code markup--p-code">for</code> loop.</p><figure name="22c2" id="22c2" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 583px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 83.3%;"></div><img class="graf-image" data-image-id="1*k6ThFBJ1_Wm1i-Wqu10HFw.png" data-width="1404" data-height="1170" src="https://cdn-images-1.medium.com/max/800/1*k6ThFBJ1_Wm1i-Wqu10HFw.png"></div><figcaption class="imageCaption">Showing the steps from top to bottom for the factorial recursive function</figcaption></figure><figure name="9214" id="9214" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 679px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 97%;"></div><img class="graf-image" data-image-id="1*dDy6r1_y-a0ey-hY8KbT_Q.png" data-width="1400" data-height="1358" src="https://cdn-images-1.medium.com/max/800/1*dDy6r1_y-a0ey-hY8KbT_Q.png"></div><figcaption class="imageCaption">Verification that the recursive function defined produces the correct result</figcaption></figure><p name="b072" id="b072" class="graf graf--p graf-after--figure">So, it is clear from the two figures above that the recursive function that we defined earlier,</p><pre name="187c" id="187c" class="graf graf--pre graf-after--p">factorial(N) = N * factorial(N - 1)</pre><p name="f314" id="f314" class="graf graf--p graf-after--pre">is indeed correct. Have a look at the Python code snippet used to find the factorial of a function, recursively.</p><figure name="c48a" id="c48a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/a87fa4fe17c0c8ee3815b7859a0cd13c.js"></script></figure><p name="9b78" id="9b78" class="graf graf--p graf-after--figure">This example was pretty simple. Let us consider a slightly bigger but standard example to demonstrate the concept of recursion.</p><h3 name="7a65" id="7a65" class="graf graf--h3 graf-after--p">Fibonacci Sequence</h3><p name="3a15" id="3a15" class="graf graf--p graf-after--h3">You must be already familiar with the famous fibonacci sequence. For those of you who have’t heard about this sequence or seen an example before, lets have a look.</p><pre name="8f1b" id="8f1b" class="graf graf--pre graf-after--p">1 1  2   3     5           8                       13 ..... </pre><p name="af07" id="af07" class="graf graf--p graf-after--pre">Let us look at the formula for calculating the n^th fibonacci number.</p><pre name="b698" id="b698" class="graf graf--pre graf-after--p">F(n) = F(n - 1) + F(n - 2)<br>where F(1) = F(2) = 1</pre><p name="cc0c" id="cc0c" class="graf graf--p graf-after--pre">Clearly, this definition of the fibonacci sequence is recursive in nature, since the n^th fibonacci number is dependent upon the previous two fibonacci numbers. This means dividing the problem into smaller subproblems, and hence recursion. Have a look at the code for this:</p><figure name="582b" id="582b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/62631e1b7e4081c677db31dbfd141732.js"></script></figure><p name="0013" id="0013" class="graf graf--p graf-after--figure">Every recursive problem must have two necessary things:</p><ol class="postList"><li name="328f" id="328f" class="graf graf--li graf-after--p">The recurrence relation defining the states of the problem and how the main problem can be broken down into smaller subproblems. This also includes the base case for stopping the recursion.</li><li name="13d1" id="13d1" class="graf graf--li graf-after--li">A recursion tree that showcases the first few, if not all calls to the function under consideration. Have a look at the recursion tree for the fibonacci sequences’ recursive relation.</li></ol><figure name="ca81" id="ca81" class="graf graf--figure graf-after--li"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 749px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 106.89999999999999%;"></div><img class="graf-image" data-image-id="1*2VfyZniOm8hK7w6NYq7Phw.png" data-width="1210" data-height="1294" src="https://cdn-images-1.medium.com/max/800/1*2VfyZniOm8hK7w6NYq7Phw.png"></div><figcaption class="imageCaption">Recursion tree showing the sequence of calls for the fibonacci recurrence relation.</figcaption></figure><p name="d257" id="d257" class="graf graf--p graf-after--figure">The recursion tree shows us that the results obtained from processing the two subtrees of the root N can be used to compute the result for the tree rooted at N. Similarly for other nodes.</p><p name="1b20" id="1b20" class="graf graf--p graf-after--p">The leaves of this recursion tree would be <code class="markup--code markup--p-code">fibonacci(1)</code> or <code class="markup--code markup--p-code">fibonacci(2)</code> both of which represent the base cases for this recursion.</p><p name="3f0a" id="3f0a" class="graf graf--p graf-after--p">Now that we have a very basic grasp of recursion, what a recurrence relation is, and the recursion tree, let’s move onto something more interesting.</p><p name="a5c2" id="a5c2" class="graf graf--p graf-after--p">Examples!</p><p name="3a6b" id="3a6b" class="graf graf--p graf-after--p">I strongly believe in solving umpteen number of examples for any given topic in programming to become a master of that topic. The two examples we considered (Factorial of a number and the Fibonacci sequence) had well defined recurrence relations. Let us look at a few examples where the recurrence relation might not be so obvious.</p><h3 name="5422" id="5422" class="graf graf--h3 graf-after--p">Height of a Tree</h3><p name="2dd6" id="2dd6" class="graf graf--p graf-after--h3">To keep things simple for this example, we will only consider a binary tree. So, a binary tree is a tree data structure in which each node has at most two children. One node of the tree is designated as the root of the tree, for example:</p><figure name="e00e" id="e00e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 853px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 121.8%;"></div><img class="graf-image" data-image-id="1*XAVkpjgzPOGiEsKVgvBd9A.png" data-width="1266" data-height="1542" src="https://cdn-images-1.medium.com/max/800/1*XAVkpjgzPOGiEsKVgvBd9A.png"></div><figcaption class="imageCaption">A Tree rooted at ‘A’ with its height and the corresponding path highlighted.</figcaption></figure><p name="dc81" id="dc81" class="graf graf--p graf-after--figure">Let’s define what we mean by the height of the binary tree.</p><blockquote name="6c50" id="6c50" class="graf graf--pullquote graf-after--p">Height of the tree would be the length of the longest root to leaf path in the tree.</blockquote><p name="48a9" id="48a9" class="graf graf--p graf-after--pullquote">So, for the example diagram displayed above, considering that the node labelled as <code class="markup--code markup--p-code">A</code> as the root of the tree, the longest root to leaf path is <code class="markup--code markup--p-code">A → C → E → G → I </code>. Essentially, the height of this tree is <code class="markup--code markup--p-code">5</code> if we count the number of nodes and <code class="markup--code markup--p-code">4</code> if we just count the number of edges on the longest path.</p><p name="a47e" id="a47e" class="graf graf--p graf-after--p">Now, forget about the entire tree and just focus on the portions highlighted in the diagram below.</p><figure name="45ab" id="45ab" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 574px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 82.1%;"></div><img class="graf-image" data-image-id="1*h0454CLOXfyvp_u02F4-fQ.png" data-width="1372" data-height="1126" src="https://cdn-images-1.medium.com/max/800/1*h0454CLOXfyvp_u02F4-fQ.png"></div><figcaption class="imageCaption">Tree rooted at node A and it’s two subtrees with their respective heights.</figcaption></figure><p name="cf72" id="cf72" class="graf graf--p graf-after--figure">The above figure shows us that we can represent a tree in the form of its subtrees. Essentially, the structure to the left of node A and the structure to the right of A is also a binary tree in itself, just smaller and with different root nodes. But, they are binary trees nonetheless.</p><p name="f67a" id="f67a" class="graf graf--p graf-after--p">What information can we get from these two subtrees that would help us find the height of the main tree rooted at A ?</p><p name="65cb" id="65cb" class="graf graf--p graf-after--p">If we knew the height of the left subtree, say <code class="markup--code markup--p-code">h1</code>, and the height of the right subtree, say <code class="markup--code markup--p-code">h2</code>, then we can simply say that the <code class="markup--code markup--p-code">maximum of the two + 1</code> for the node A would give us the height of our tree. Isn’t that right?</p><p name="63f1" id="63f1" class="graf graf--p graf-after--p">Formalizing this recursive relation,</p><pre name="3102" id="3102" class="graf graf--pre graf-after--p">height(root) = max(height(root.left), height(root.right)) + 1</pre><p name="4a7f" id="4a7f" class="graf graf--p graf-after--pre">So, that’s the recursive definition of the height of a <strong class="markup--strong markup--p-strong">binary</strong> tree. The focus is on binary here, because we used just two children of the node <code class="markup--code markup--p-code">root </code>represented by <code class="markup--code markup--p-code">root.left </code>and <code class="markup--code markup--p-code">root.right.</code> But, it is easy to extend this recursive relation to an n-ary tree. Let’s take a look at this in code.</p><figure name="b738" id="b738" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/87de419cc4c84cb7c48a7c44b2c8ebf0.js"></script></figure><p name="9b9a" id="9b9a" class="graf graf--p graf-after--figure">The problem here was greatly simplified because we let recursion do all the heavy lifting for us. We simply used <strong class="markup--strong markup--p-strong">optimal<em class="markup--em markup--p-em"> </em></strong>answers for our subproblems to find a solution to our original problem.</p><p name="b8a4" id="b8a4" class="graf graf--p graf-after--p">Let’s look at another example that can be solved on similar lines.</p><h3 name="b460" id="b460" class="graf graf--h3 graf-after--p">Number of Nodes in a Tree</h3><p name="2780" id="2780" class="graf graf--p graf-after--h3">Here again, we will consider a binary tree for simplicity, but the algorithm and the approach can be extended to any kind of tree essentially.</p><p name="2880" id="2880" class="graf graf--p graf-after--p">The problem is itself very self explanatory. Given the root of a binary tree, we need to determine the total number of nodes in the tree. This question and the approach we will come up with here are very similar to the previous one. We just have to make minuscule changes and we will have the number of nodes in the binary tree.</p><p name="8384" id="8384" class="graf graf--p graf-after--p">Take a look at the diagram below.</p><figure name="cdca" id="cdca" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 583px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 83.3%;"></div><img class="graf-image" data-image-id="1*Fu_K_bkWs5ECzVwFnuakhA.png" data-width="1316" data-height="1096" src="https://cdn-images-1.medium.com/max/800/1*Fu_K_bkWs5ECzVwFnuakhA.png"></div></figure><p name="1984" id="1984" class="graf graf--p graf-after--figure">The diagram says it all. We already know that a tree can be broken down into smaller subtrees. Here again, we can ask ourselves,</p><blockquote name="f68d" id="f68d" class="graf graf--pullquote graf-after--p">What information can we get from these two subtrees that would help us find the number of nodes in the tree rooted at A?</blockquote><p name="2d15" id="2d15" class="graf graf--p graf-after--pullquote">Well, if we knew the number of nodes in the left subtree and the number of nodes in the right subtree, we can simply add them up and add one for the root node and that would give us the total number of nodes.</p><p name="a41b" id="a41b" class="graf graf--p graf-after--p">Formalizing this we get,</p><pre name="78c8" id="78c8" class="graf graf--pre graf-after--p">number_of_nodes(root) = number_of_nodes(root.left) + number_of_nodes(right) + 1</pre><p name="c64c" id="c64c" class="graf graf--p graf-after--pre">If you look at this recursion and the previous one, you will find that they are extremely similar. The only thing that is varying is what we do with the information we obtained from our subproblems and how we combined them to get some answer.</p><figure name="a155" id="a155" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/97cfaa0d09e9139c0710dae50c895b2e.js"></script></figure><p name="3621" id="3621" class="graf graf--p graf-after--figure">Now that we have seen a couple of easy examples with a binary tree, let’s move onto something less trivial.</p><h3 name="5044" id="5044" class="graf graf--h3 graf-after--p">Merge Sort</h3><p name="cd2c" id="cd2c" class="graf graf--p graf-after--h3">Given an array of numbers like</p><pre name="5a70" id="5a70" class="graf graf--pre graf-after--p">4 2 8 9 1 5 2</pre><p name="50ac" id="50ac" class="graf graf--p graf-after--pre">we need to come up with a sorting technique that sorts them either in ascending or descending order. There are a lot of famous sorting techniques out there for this like <a href="https://en.wikipedia.org/wiki/Quicksort" data-href="https://en.wikipedia.org/wiki/Quicksort" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Quick Sort</a>, <a href="https://en.wikipedia.org/wiki/Heapsort" data-href="https://en.wikipedia.org/wiki/Heapsort" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Heap Sort</a>, <a href="https://en.wikipedia.org/wiki/Radix_sort" data-href="https://en.wikipedia.org/wiki/Radix_sort" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Radix Sort</a> and so on. But we are specifically going to look at a technique called the Merge Sort.</p><p name="d755" id="d755" class="graf graf--p graf-after--p">It’s possible that a lot of you are familiar with the <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" data-href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Divide and Conquer paradigm</a>, and this might feel redundant. But bear with me and read on!</p><p name="e4c7" id="e4c7" class="graf graf--p graf-after--p">The idea here is to break it down into subproblems.</p><figure name="0c05" id="0c05" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://giphy.com/embed/26gsaLkUSO6uNiXsc/twitter/iframe" width="100%" height="300" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption"><a href="https://giphy.com/gifs/latelateshow-clapping-james-corden-26gsaLkUSO6uNiXsc" data-href="https://giphy.com/gifs/latelateshow-clapping-james-corden-26gsaLkUSO6uNiXsc" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://giphy.com/gifs/latelateshow-clapping-james-corden-26gsaLkUSO6uNiXsc</a></figcaption></figure><p name="1d23" id="1d23" class="graf graf--p graf-after--figure">That’s what the article is about right ? 😛</p><p name="0865" id="0865" class="graf graf--p graf-after--p">What if we had two sorted halves of the original array. Can we use them somehow to sort the entire array?</p><p name="1162" id="1162" class="graf graf--p graf-after--p">That’s the main idea here. The task of sorting an array can be broken down into two smaller subtasks:</p><ul class="postList"><li name="8e83" id="8e83" class="graf graf--li graf-after--p">sorting two different halves of the array</li><li name="12a4" id="12a4" class="graf graf--li graf-after--li">then using those sorted halves to obtain the original sorted array</li></ul><p name="6bc6" id="6bc6" class="graf graf--p graf-after--li">Now, the beauty about recursion is, you don’t need to worry about how we will get two sorted halves and what logic will go into that. Since this is recursion, the same method call to <code class="markup--code markup--p-code">merge_sort</code> would sort the two halves for us. All we need to do is focus on what we need to do once we have the sorted haves with us.</p><p name="34f4" id="34f4" class="graf graf--p graf-after--p">Let’s go through the code:</p><figure name="6567" id="6567" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/35a3f34c1c13e736d717eb92c4c7073e.js"></script></figure><p name="6686" id="6686" class="graf graf--p graf-after--figure">At this point, we trusted and relied on our good friend recursion and assumed that <code class="markup--code markup--p-code">left_sorted_half</code> and <code class="markup--code markup--p-code">right_sorted_half</code> would in fact contain the two sorted halves of the original array.</p><p name="7a39" id="7a39" class="graf graf--p graf-after--p">So, what next?</p><p name="4e24" id="4e24" class="graf graf--p graf-after--p">The question is how to combine them somehow to give the entire array.</p><p name="b06c" id="b06c" class="graf graf--p graf-after--p">The problem now simply boils down to merging two sorted arrays into one. This is a pretty standard problem and can be solved by what is known as the “two finger approach”.</p><p name="2fe8" id="2fe8" class="graf graf--p graf-after--p">Take a look at the pseudo code for better understanding.</p><pre name="ed8a" id="ed8a" class="graf graf--pre graf-after--p">let L and R be our two sorted halves. <br>let ans be the combined, sorted array <br>l = 0 // The pointer for the left half<br>r = 0 // The pointer for the right half<br>a = 0 // The pointer for the array ans <br>while l &lt; L.length and r &lt; R.length {<br>      if L[l] &lt; R[r] {<br>           ans[a] = L[l]<br>           l++<br>       } else {<br>           ans[a] = R[r]<br>           r++<br>      }<br>} <br>copy remaining array portion of L or R, whichever was longer, into ans.</pre><p name="0eb6" id="0eb6" class="graf graf--p graf-after--pre">Here we have two pointers (fingers), and we position them at the start of the individual halves. We check which one is smaller (that is, which value pointed at by the finger is smaller), and we add that value to our sorted combined array. We then advance the respective pointer (finger) forward. In the end we copy the remaining portion of the longer array and add it to the back of the <code class="markup--code markup--p-code">ans</code> array.</p><p name="6a90" id="6a90" class="graf graf--p graf-after--p">So, the combined code for merge-sort is as follows:</p><figure name="36ad" id="36ad" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/2ddf8ef17df8c6d1b54d2d6973cbacec.js"></script></figure><p name="a8f7" id="a8f7" class="graf graf--p graf-after--figure">We will do one final question using recursion and trust me, it’s a tough one and a pretty confusing one. But before moving onto that, I will iterate the steps I follow whenever I have to think of a recursive solution to a problem.</p><h3 name="5225" id="5225" class="graf graf--h3 graf-after--p">Steps to come up with a Recursive Solution</h3><ol class="postList"><li name="33cf" id="33cf" class="graf graf--li graf-after--h3">Try and break down the problem into subproblems.</li></ol><figure name="9acd" id="9acd" class="graf graf--figure graf-after--li"><div class="aspectRatioPlaceholder is-locked" style="max-width: 600px; max-height: 399px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.5%;"></div><img class="graf-image" data-image-id="1*aak-cm8casUG2vyVhlBVIw.png" data-width="600" data-height="399" src="https://cdn-images-1.medium.com/max/800/1*aak-cm8casUG2vyVhlBVIw.png"></div><figcaption class="imageCaption">Source: <a href="https://www.weheartswift.com/compute-2-power-n/" data-href="https://www.weheartswift.com/compute-2-power-n/" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://www.weheartswift.com/compute-2-power-n/</a></figcaption></figure><p name="082a" id="082a" class="graf graf--p graf-after--figure">2. Once you have the subproblems figured out, think about what information from the call to the subproblems can you use to solve the task at hand. For example, the factorial of <code class="markup--code markup--p-code">N — 1</code> to find the factorial of <code class="markup--code markup--p-code">N</code> , height of the left and right subtrees to find the height of the main tree, and so on.</p><figure name="f19e" id="f19e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 671px; max-height: 588px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 87.6%;"></div><img class="graf-image" data-image-id="1*deig5GtZ71owj63KcdEJcg.png" data-width="671" data-height="588" src="https://cdn-images-1.medium.com/max/800/1*deig5GtZ71owj63KcdEJcg.png"></div></figure><p name="72e4" id="72e4" class="graf graf--p graf-after--figure">3. Keep calm and trust recursion! Assume that your recursive calls to the subproblems will return the information you need in the most optimal fashion.</p><figure name="7534" id="7534" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 525px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75%;"></div><img class="graf-image" data-image-id="1*ViEEM9XNagm79MAW5GR2mw.png" data-width="1600" data-height="1200" src="https://cdn-images-1.medium.com/max/800/1*ViEEM9XNagm79MAW5GR2mw.png"></div><figcaption class="imageCaption">Source: <a href="https://neildanson.files.wordpress.com/2014/02/keep-calm-it-just-works.png" data-href="https://neildanson.files.wordpress.com/2014/02/keep-calm-it-just-works.png" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://neildanson.files.wordpress.com/2014/02/keep-calm-it-just-works.png</a></figcaption></figure><p name="8d2c" id="8d2c" class="graf graf--p graf-after--figure">4. The final step in this process is actually using information we just got from the subproblems to find the solution to the main problem. Once you have that, you’re ready to code up your recursive solution.</p><p name="b715" id="b715" class="graf graf--p graf-after--p">Now that we have all the steps lined up, let’s move on to our final problem in this article. It’s called <a href="https://leetcode.com/problems/sum-of-distances-in-tree/description/" data-href="https://leetcode.com/problems/sum-of-distances-in-tree/description/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Sum of Distances in a Tree.</a></p><h3 name="792e" id="792e" class="graf graf--h3 graf-after--p">Sum of Distances in a Tree</h3><p name="3ae9" id="3ae9" class="graf graf--p graf-after--h3">Let’s look at what the question is asking us to do here. Consider the following tree.</p><figure name="563b" id="563b" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 714px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 102%;"></div><img class="graf-image" data-image-id="1*U3An6J_vH3b2Ej0SO_XpUw.png" data-width="1328" data-height="1354" src="https://cdn-images-1.medium.com/max/800/1*U3An6J_vH3b2Ej0SO_XpUw.png"></div><figcaption class="imageCaption">Example tree showing the expected output of our program for the various nodes.</figcaption></figure><p name="2639" id="2639" class="graf graf--p graf-after--figure">In the example above, the sum of paths for the node A (the number of nodes on <strong class="markup--strong markup--p-strong">each path</strong> from <code class="markup--code markup--p-code">A</code> to every other vertex in the tree) is 9. The individual paths are mentioned in the diagram itself with their respective lengths.</p><p name="ca6d" id="ca6d" class="graf graf--p graf-after--p">Similarly, consider the sum of distances for the node C.</p><pre name="5291" id="5291" class="graf graf--pre graf-after--p">C --&gt; A --&gt; B (Length 2)<br>C --&gt; A (Length 1)<br>C --&gt; D (Length 1)<br>C --&gt; E (Length 1)<br>C --&gt; D --&gt; F (Length 2)<br>Sum of distances (C) = 2 + 1 + 1 + 1 + 2 = 7</pre><p name="1065" id="1065" class="graf graf--p graf-after--pre">This is known as the sum of distances as defined for just a single node A or C. We need to calculate these distances for each of the nodes in the tree.</p><p name="65cc" id="65cc" class="graf graf--p graf-after--p">Before actually solving this generic problem, let us consider a simplified version of the same problem. It says that we just need to calculate the sum of distances for a given node, but we will only consider the tree rooted at the given node for calculations.</p><p name="5752" id="5752" class="graf graf--p graf-after--p">So, for the node C, this simplified version of the problem would ask us to calculate:</p><pre name="71e3" id="71e3" class="graf graf--pre graf-after--p">C --&gt; D (Length 1)<br>C --&gt; E (Length 1)<br>C --&gt; D --&gt; F (Length 2)<br>Simplified Sum of Distances (C) = 1 + 1 + 2 = 4</pre><p name="2705" id="2705" class="graf graf--p graf-after--pre">This is a much simpler problem to tackle recursively and would prove to be useful in solving the original problem.</p><p name="8ac3" id="8ac3" class="graf graf--p graf-after--p">Consider the following simple tree.</p><figure name="e268" id="e268" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 779px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 111.3%;"></div><img class="graf-image" data-image-id="1*bomBBwkaLxNXqUGno7rD6Q.png" data-width="1346" data-height="1498" src="https://cdn-images-1.medium.com/max/800/1*bomBBwkaLxNXqUGno7rD6Q.png"></div><figcaption class="imageCaption">The simple tree we would consider for now. Also mentioned are two values we would be computing for every node.</figcaption></figure><p name="1a21" id="1a21" class="graf graf--p graf-after--figure">The nodes B and C are the children of the root (that is, A).</p><p name="408b" id="408b" class="graf graf--p graf-after--p">We are trying to see what information can we use from subproblems (the children) to compute the answer for the root <code class="markup--code markup--p-code">A</code> .</p><p name="cedf" id="cedf" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Note</strong>: here we simply want to calculate the sum of paths for a given node X to all its successors in its own subtree (the tree rooted at the node X).</p><p name="9843" id="9843" class="graf graf--p graf-after--p">There are no downwards going paths from the node B, and so the sum of paths is 0 for the node <code class="markup--code markup--p-code">B</code> in this tree. Let’s look at the node <code class="markup--code markup--p-code">C</code> . So this node has 3 different successors in <code class="markup--code markup--p-code">F, D and E</code> . The sum of distances are as follows:</p><pre name="2cbf" id="2cbf" class="graf graf--pre graf-after--p">C --&gt; D (Path containing just 1 edge, hence sum of distances = 1)<br>C --&gt; D --&gt; F (Path containing 2 edges, hence sum of distances = 2)<br>C --&gt; E (Path containing just 1 edge, hence sum of distances = 1)</pre><p name="dbf4" id="dbf4" class="graf graf--p graf-after--pre">The sum of all the paths from the node <code class="markup--code markup--p-code">C</code> to all of its decedents is 4, and number of such paths going down is 3.</p><p name="259c" id="259c" class="graf graf--p graf-after--p">Note the difference here. The <code class="markup--code markup--p-code">sum_of_distances</code> here counts the number of edges in each path — with each edge repeating multiple times, probably because of their occurrence on different paths — unlike <code class="markup--code markup--p-code">number_of_paths</code> , which counts, well, the number of paths 😝.</p><p name="735a" id="735a" class="graf graf--p graf-after--p">If you look closely, you will realize that the number of paths going down is always going to be the number of nodes in the tree we are considering (except the root). So, for the tree rooted at C, we have 3 paths, one for the node D, one for E, and one for F. This means that the number of paths from a given node to the successor nodes is simply the total number of descendent nodes since this is a tree. So, no cycles or multiple edges.</p><p name="58b0" id="58b0" class="graf graf--p graf-after--p">Now, consider the node A. Let us look at all the new paths that are being introduced because of this node A. Forget the node B for now and just focus on the child node C corresponding to A. The new sets of paths that we have are:</p><pre name="98cd" id="98cd" class="graf graf--pre graf-after--p">A --&gt; C (Path containing just 1 edge, hence sum of distances = 1)<br>A --&gt; (C --&gt; D)    (Path containing 2 edges, hence sum of distances = 2)<br>A --&gt; (C --&gt; E)    (Path containing 2 edges, hence sum of distances = 2)<br>A --&gt; (C --&gt; D --&gt; F) (Path containing 3 edges, hence sum of distances = 3)</pre><p name="eee0" id="eee0" class="graf graf--p graf-after--pre">Except for the first path <code class="markup--code markup--p-code">A → C</code>, all the others are the same as the ones for the node C, except that we have simply changed all of them and incorporated one extra node <code class="markup--code markup--p-code">A</code>.</p><figure name="c559" id="c559" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 535px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 76.4%;"></div><img class="graf-image" data-image-id="1*Q4kSg7rwJMxc4Ca17YdzBw.png" data-width="1452" data-height="1110" src="https://cdn-images-1.medium.com/max/800/1*Q4kSg7rwJMxc4Ca17YdzBw.png"></div><figcaption class="imageCaption">Sum of distances for the node A along with contribution from the node C.</figcaption></figure><p name="7020" id="7020" class="graf graf--p graf-after--figure">If you look at the diagram above you will see a tuple of values next to each of the nodes A, B, and C.</p><pre name="39f6" id="39f6" class="graf graf--pre graf-after--p">(X, Y) where <br>X is the number of paths originating at that node and going down to the decedents. <br>Y is the sum of distances for the tree rooted at the given node. </pre><p name="0aba" id="0aba" class="graf graf--p graf-after--pre">Since the node B doesn’t have any further children, the only path it is contributing to is the path <code class="markup--code markup--p-code">A --&gt; B</code> to <code class="markup--code markup--p-code">A&#39;s</code> tuple of (5, 9) above. So let’s talk about C.</p><p name="442a" id="442a" class="graf graf--p graf-after--p">C had three paths going to its successors. Those three paths (extended by one more node for A) also become three paths from A to its successors, among others.</p><pre name="ad6b" id="ad6b" class="graf graf--pre graf-after--p">N-Paths[A] = (N-Paths[C] + 1) + (N-Paths[B] + 1)</pre><p name="7e6e" id="7e6e" class="graf graf--p graf-after--pre">That is the exact relation we are looking for as far as the number of paths (= number of successor nodes in the tree) are concerned. The 1 is because of the new path from the root to it’s child, that is <code class="markup--code markup--p-code">A --&gt; C</code> in our case.</p><pre name="9ffa" id="9ffa" class="graf graf--pre graf-after--p">N-Paths[A] = 3 + 1 + 0 + 1 = 5</pre><p name="a0ef" id="a0ef" class="graf graf--p graf-after--pre">As far as the sum of distances is concerned, take a look at the diagram and the equations we just wrote. The following formula becomes very clear:</p><pre name="d180" id="d180" class="graf graf--pre graf-after--p">Sum-Dist[A] = (N-Paths[C] + 1 + Sum-Dist[C]) + (N-Paths[B] + 1 + Sum-Dist[B]) Sum-Dist[A] = (3 + 1 + 4 + 0 + 1 + 0) = 9</pre><p name="3d9e" id="3d9e" class="graf graf--p graf-after--pre">The main thing here is <code class="markup--code markup--p-code">N-Paths[C] + Sum-Dist[C]</code> . We sum these up because all of the paths from C to its descendants ultimately become the paths from A to its descendants — except that they originate at A and go through C, and so each of the path lengths are increased by 1. There are <code class="markup--code markup--p-code">N-Paths[C]</code> paths in all originating from C and their total length is given by <code class="markup--code markup--p-code">Sum-Dist[C]</code> .</p><p name="9101" id="9101" class="graf graf--p graf-after--p">Hence the tuple corresponding to A = (5, 9). The Python code for the algorithm we discussed above is as follows:</p><figure name="7f39" id="7f39" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/f89850fc7353c7662fac133ebd49c793.js"></script></figure><h4 name="3e82" id="3e82" class="graf graf--h4 graf-after--figure">The Curious Case of the Visited Dictionary :/</h4><p name="45ac" id="45ac" class="graf graf--p graf-after--h4">If you look at the code above closely, you’ll see this:</p><pre name="7481" id="7481" class="graf graf--pre graf-after--p"># Prevents the recursion from going into a cycle.        self.visited[vertex] = 1</pre><p name="2aef" id="2aef" class="graf graf--p graf-after--pre">The comment says that this <code class="markup--code markup--p-code">visited</code> dictionary is for preventing the recursion from entering a cycle.</p><p name="3fea" id="3fea" class="graf graf--p graf-after--p">If you’ve paid attention til now, you know that we are dealing with a <code class="markup--code markup--p-code">tree</code> here.</p><p name="827a" id="827a" class="graf graf--p graf-after--p">The definition of a tree data structure doesn’t allow cycles to exist. If a cycle exists in the structure, then it is no longer a tree, it becomes a graph. In a tree, there is exactly one path between any two pair of vertices. A cycle would mean there is more than one path between a pair of vertices. Look at the figures below.</p><figure name="b477" id="b477" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 479px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 68.4%;"></div><img class="graf-image" data-image-id="1*vtO_LgKcmR19kzmCgSrSYw.png" data-width="2144" data-height="1466" src="https://cdn-images-1.medium.com/max/800/1*vtO_LgKcmR19kzmCgSrSYw.png"></div><figcaption class="imageCaption">Tree vs Graph. Showing the cycle.</figcaption></figure><p name="52e3" id="52e3" class="graf graf--p graf-after--figure">The structure on the left is a tree. It has no cycles in it. There is a unique path between any two vertices.</p><p name="9fae" id="9fae" class="graf graf--p graf-after--p">The structure on the right is a graph, there exists a cycle in the graph and hence there are multiple paths between any pair of vertices. For this graph, it so happens that any pair of vertices have more than one path. This is not necessary for every graph.</p><p name="aaf2" id="aaf2" class="graf graf--p graf-after--p">Almost always, we are given the <code class="markup--code markup--p-code">root</code> node of the tree. We can use the root node to traverse the entire tree <strong class="markup--strong markup--p-strong">without having to worry about any cycles as such<em class="markup--em markup--p-em">.</em></strong></p><p name="148b" id="148b" class="graf graf--p graf-after--p">However, if you’ve read the problem statement clearly, it does not state anything about root of the tree.</p><p name="229a" id="229a" class="graf graf--p graf-after--p">That means that there is no designated root for the tree given in the question. This could mean that a given tree can be visualized and processed in so many different ways depending upon what we consider as the root. Have a look at multiple structures for the same tree but with different root nodes.</p><figure name="3ae8" id="3ae8" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 625px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 89.3%;"></div><img class="graf-image" data-image-id="1*DR9CZIanW-su89jiCPDtVg.png" data-width="1416" data-height="1264" src="https://cdn-images-1.medium.com/max/800/1*DR9CZIanW-su89jiCPDtVg.png"></div><figcaption class="imageCaption">Multiple orientations of the same tree with different roots.</figcaption></figure><p name="1a8f" id="1a8f" class="graf graf--p graf-after--figure">So many different interpretations and parent child relationships are possible for a given <strong class="markup--strong markup--p-strong">unrooted tree<em class="markup--em markup--p-em">.</em></strong></p><p name="4cf3" id="4cf3" class="graf graf--p graf-after--p">So, we start with the node <code class="markup--code markup--p-code">0</code> and do a DFS traversal of the given structure. In the process we fix the parent child relationships. Given the edges in the problem, we construct an undirected graph-like structure which we convert to the tree structure. Taking a look at the code should clear up some of your doubts:</p><figure name="5a68" id="5a68" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/ecbea2efcb9a3c87249e4444f35e68fb.js"></script></figure><p name="362c" id="362c" class="graf graf--p graf-after--figure">Every node would have one parent. The root won’t have any parent, and the way this logic is, the node <code class="markup--code markup--p-code">0</code> would become the root of our tree. Note that we are not doing this process separately and then calculating the <code class="markup--code markup--p-code">sum of distances downwards</code>. Given a tree, we were trying to find, for every node, the simplified sum of distances for the tree rooted at that node.</p><p name="792d" id="792d" class="graf graf--p graf-after--p">So, the conversion from the graph to the tree happens in one single iteration along with finding out the sum of distances downwards for each and every node.</p><figure name="aff1" id="aff1" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/f89850fc7353c7662fac133ebd49c793.js"></script></figure><p name="4eb9" id="4eb9" class="graf graf--p graf-after--figure">I posted the code again so that the <code class="markup--code markup--p-code">visited</code> dictionary makes much more sense now. So, one single recursion doing all that for us. Nice!</p><h4 name="1765" id="1765" class="graf graf--h4 graf-after--p">Bringing it all together</h4><p name="d0b6" id="d0b6" class="graf graf--p graf-after--h4">Now that we have our tree structure defined, and also the values of <code class="markup--code markup--p-code">sum of distances going downward</code> defined for us, we can use all of this information to solve the original problem of <a href="https://leetcode.com/problems/sum-of-distances-in-tree/description/" data-href="https://leetcode.com/problems/sum-of-distances-in-tree/description/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Sum of Distances in a Tree.</a></p><p name="81b6" id="81b6" class="graf graf--p graf-after--p">How do we do that? It’s best to explain this algorithm with the help of an example. So we will consider the tree below and we will dry run the algorithm for a single node. Let’s have a look at the tree we will be considering.</p><figure name="8b78" id="8b78" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 687px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 98.1%;"></div><img class="graf-image" data-image-id="1*_X74YieQAGUCmZvBXwIgWQ.png" data-width="1270" data-height="1246" src="https://cdn-images-1.medium.com/max/800/1*_X74YieQAGUCmZvBXwIgWQ.png"></div><figcaption class="imageCaption">The tree we will be considering for our explanation moving on.</figcaption></figure><p name="97b1" id="97b1" class="graf graf--p graf-after--figure">The node for which we want to find the sum of distances is <code class="markup--code markup--p-code">4</code>. Now, if you remember the simpler problem we were trying to solve earlier, you know that we already have two values associated with each of the nodes:</p><ol class="postList"><li name="2d60" id="2d60" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">distances_down</code> Which is the sum of distances for this node <strong class="markup--strong markup--li-strong">while only considering the tree beneath<em class="markup--em markup--li-em">.</em></strong></li><li name="2250" id="2250" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">number_of_paths_down</code> which is the number of paths / nodes in the tree rooted at the node under consideration.</li></ol><p name="a414" id="a414" class="graf graf--p graf-after--li">Let’s look at the annotated version of the above tree. The tree is annotated with tuples <code class="markup--code markup--p-code">(distances_down, number_of_paths_down)</code> .</p><figure name="6b05" id="6b05" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 653px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 93.30000000000001%;"></div><img class="graf-image" data-image-id="1*8O6xTkG84fkHB3og3rXtzA.png" data-width="1496" data-height="1396" src="https://cdn-images-1.medium.com/max/800/1*8O6xTkG84fkHB3og3rXtzA.png"></div><figcaption class="imageCaption">Example tree with annotated values for all nodes.</figcaption></figure><p name="4f15" id="4f15" class="graf graf--p graf-after--figure">Let’s call the value we want to compute for each node as <code class="markup--code markup--p-code">sod</code> which means sum of distances, which is what the question originally asks us to compute.</p><p name="7d92" id="7d92" class="graf graf--p graf-after--p">Let us assume that we have already computed the answer for the parent node of <code class="markup--code markup--p-code">4</code> in the diagram above. So, we now have the following information for the node labelled <code class="markup--code markup--p-code">2</code> (the parent node) available:</p><p name="ead4" id="ead4" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">(sod, distances_down, number_of_paths_down)</code> = <code class="markup--code markup--p-code">(13, 4, 3)</code></p><p name="59b7" id="59b7" class="graf graf--p graf-after--p">Let’s rotate the given tree and visualize it in a way where <code class="markup--code markup--p-code">2</code> is the root of the tree essentially.</p><figure name="9f2b" id="9f2b" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 566px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 80.80000000000001%;"></div><img class="graf-image" data-image-id="1*TmKowuiShc8NCwxP-9VvOg.png" data-width="1500" data-height="1212" src="https://cdn-images-1.medium.com/max/800/1*TmKowuiShc8NCwxP-9VvOg.png"></div><figcaption class="imageCaption">Rotated tree showing the tree rooted at 4 should be removed.</figcaption></figure><p name="1f96" id="1f96" class="graf graf--p graf-after--figure">Now, we want to remove the contribution of the tree rooted at <code class="markup--code markup--p-code">4</code> from <code class="markup--code markup--p-code">sod(2)</code>. Let us consider all of the paths from the parent node <code class="markup--code markup--p-code">2</code> to all other nodes except the ones in the tree rooted at <code class="markup--code markup--p-code">4</code> .</p><pre name="f5f8" id="f5f8" class="graf graf--pre graf-after--p">2 --&gt; 5 (1 edge)<br>2 --&gt; 1 (1 edge)<br>2 --&gt; 1 --&gt;7 (2 edges)<br>2 --&gt; 1 --&gt; 7 --&gt; 9 (3 edges)<br>2 --&gt; 1 --&gt; 7 --&gt; 10 (3 edges) <br> Number of nodes considered = 6<br>Sum of paths remaining i.e. sod(2) rem = 1 + 1 + 2 + 3 + 3 = 10</pre><p name="9144" id="9144" class="graf graf--p graf-after--pre">Let’s see how we can use the values we already have calculated to get these updated values.</p><pre name="d045" id="d045" class="graf graf--pre graf-after--p">* N = 8 (Total number of nodes in the tree. This will remain the same for every node.)<br><br>* sod(2) = 13 <br><br>* distances_down[4] = 1<br><br>* number_of_paths_down[4] = 1 <br><br>* (distances_down[4] does not include the node 4 itself) <br><br>N - 1 - distances_down[4] = 8 - 1 - 1 = 6 <br><br>* sod(2) - 1 - distances_down[4] - number_of_paths_down[4] = 13 - 1 - 1 - 1 = 10</pre><p name="37f4" id="37f4" class="graf graf--p graf-after--pre">If you remember this from the function we defined earlier, you will notice that the contribution of a <code class="markup--code markup--p-code">child</code> node to the two values <code class="markup--code markup--p-code">distances_down and number_of_paths_down</code> is <code class="markup--code markup--p-code">n_paths + 1</code> and <code class="markup--code markup--p-code">n_paths + s_paths + 1</code> respectively. Naturally, that is what we subtract to obtain the remaining tree.</p><figure name="a4a3" id="a4a3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/b7076f6f2cda42a672c8c8e75531e0d0.js"></script></figure><p name="831a" id="831a" class="graf graf--p graf-after--figure"><code class="markup--code markup--p-code">sod(4)</code> represents the sum of edges on all the paths originating at the node <code class="markup--code markup--p-code">4</code> in the tree above. Let’s see how we can find this out using the information we have calculated till now.</p><p name="8c22" id="8c22" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">distances_down[4]</code> represents the answer for the tree rooted at the node <code class="markup--code markup--p-code">4</code> but it only considers paths going to its successors, that is all the nodes in the tree rooted at <code class="markup--code markup--p-code">4</code>. For our example, the successor of <code class="markup--code markup--p-code">4</code> is the node <code class="markup--code markup--p-code">6</code>. So, that will directly add to the final answer. Let’s call this value <code class="markup--code markup--p-code">own_answer</code> . Now, let’s account for all the other paths.</p><pre name="0cb0" id="0cb0" class="graf graf--pre graf-after--p">4 --&gt; 2 (1 edge)<br>4 --&gt; 2 --&gt; 5 (1 + 1 edge)<br>4 --&gt; 2 --&gt; 1 (1 + 1 edge)<br>4 --&gt; 2 --&gt; 1 --&gt;7 (1 + 2 edges)<br>4 --&gt; 2 --&gt; 1 --&gt; 7 --&gt; 9 (1 + 3 edges)<br>4 --&gt; 2 --&gt; 1 --&gt; 7 --&gt; 10 (1 + 3 edges)<br>own_answer = 1 <br><br>sod(4) = 1 + 1 + 2 + 2 + 3 + 4 + 4 = 17 <br><br>sod(4) = own_answer + (N - 1 - <code class="markup--code markup--pre-code">distances_down[4]) + (</code>sod(2) - 1 - <code class="markup--code markup--pre-code">distances_down[4] - number_of_paths_down[4]) = 1 + 6 + 10 = 17</code></pre><figure name="bb11" id="bb11" class="graf graf--figure graf--iframe graf-after--pre"><iframe src="https://giphy.com/embed/FX1ZGci9qPM3u/twitter/iframe" width="100%" height="300" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">Source: <a href="https://giphy.com/gifs/angry-confused-love-life-FX1ZGci9qPM3u" data-href="https://giphy.com/gifs/angry-confused-love-life-FX1ZGci9qPM3u" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">https://giphy.com/gifs/angry-confused-love-life-FX1ZGci9qPM3u</a></figcaption></figure><p name="fdc6" id="fdc6" class="graf graf--p graf-after--figure">Before you go bonkers and start doing this, let’s look at the code and bring together all of the things we discussed in the example above.</p><figure name="3627" id="3627" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/edorado93/99d8fcffc5fbdd7957e488096ddfd59b.js"></script></figure><p name="c0ef" id="c0ef" class="graf graf--p graf-after--figure">The recursive relation for this portion is as follows:</p><figure name="ef9d" id="ef9d" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 590px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 84.3%;"></div><img class="graf-image" data-image-id="1*sKrK7VgF8dHvYMoiIjZtSA.png" data-width="1468" data-height="1238" src="https://cdn-images-1.medium.com/max/800/1*sKrK7VgF8dHvYMoiIjZtSA.png"></div><figcaption class="imageCaption">Recursive relation for Sum of Distances, in its totality.</figcaption></figure><h3 name="55ef" id="55ef" class="graf graf--h3 graf-after--figure">Did I just see “MEMOIZATION” in the code?</h3><p name="464c" id="464c" class="graf graf--p graf-after--h3">Yes, indeed you did!</p><p name="97be" id="97be" class="graf graf--p graf-after--p">Consider the following example tree:</p><figure name="5f8a" id="5f8a" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 665px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 95%;"></div><img class="graf-image" data-image-id="1*SkgBwbCP1O6-wrS4u2WlZg.png" data-width="1398" data-height="1328" src="https://cdn-images-1.medium.com/max/800/1*SkgBwbCP1O6-wrS4u2WlZg.png"></div><figcaption class="imageCaption">Example of a skewed tree, also recursive calls for the vertex 5</figcaption></figure><p name="f86c" id="f86c" class="graf graf--p graf-after--figure">The question asks us to find the sum of distances for all the nodes in the given tree. So, we would do something like this:</p><pre name="8cbc" id="8cbc" class="graf graf--pre graf-after--p">for i in range(N):<br>    ans.append(find_distances(N))</pre><p name="6a1b" id="6a1b" class="graf graf--p graf-after--pre">But, if you look at the tree above, the recursive call for the node <code class="markup--code markup--p-code">5</code> would end up calculating the answers for all the nodes in the tree. So, we don’t need to recalculate the answers for the other nodes again and again.</p><p name="6d29" id="6d29" class="graf graf--p graf-after--p">Hence, we end up storing the already calculated values in a dictionary and use that in further calculations.</p><p name="0bd1" id="0bd1" class="graf graf--p graf-after--p">Essentially, the recursion is based on the parent of a node, and multiple nodes can have the same parent. So, the answer for the parent should only be calculated once and then be used again and again.</p><p name="9e13" id="9e13" class="graf graf--p graf-after--p">If you’ve managed to read the article this far (not necessarily in one stretch 😛), you’re awesome 😃.</p><figure name="eeb6" id="eeb6" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 864px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 123.4%;"></div><img class="graf-image" data-image-id="1*3vTs6DvYvHOIG_l2aeiRHw.jpeg" data-width="900" data-height="1111" src="https://cdn-images-1.medium.com/max/800/1*3vTs6DvYvHOIG_l2aeiRHw.jpeg"></div><figcaption class="imageCaption">Source: <a href="http://doodlecats.com/youre-awesome" data-href="http://doodlecats.com/youre-awesome" class="markup--anchor markup--figure-anchor" rel="nofollow noopener" target="_blank">http://doodlecats.com/youre-awesome</a></figcaption></figure><p name="5895" id="5895" class="graf graf--p graf-after--figure graf--trailing">If you found this article helpful, share as much as possible and spread the 💛. Cheers!</p></div></div></section>
</section>
</article></body></html>
